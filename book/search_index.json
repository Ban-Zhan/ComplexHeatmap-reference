[
["index.html", "ComplexHeatmap Complete Reference About", " ComplexHeatmap Complete Reference Zuguang Gu last revised on 2018-10-15 About This is the documentation of the ComplexHeatmap package. Examples in the book are generated under version 1.99.0. Please note, this documentation is not completely compatible with older versions (&lt; 1.99.0, before Oct, 2018), the major functionality keeps the same. If you use ComplexHeatmap in your publications, I am appreciated if you can cite: Gu, Z. (2016) Complex heatmaps reveal patterns and correlations in multidimensional genomic data. DOI: 10.1093/bioinformatics/btw313 "],
["introduction.html", "Chapter 1 Introduction 1.1 General design 1.2 A brief description of following chapters", " Chapter 1 Introduction Complex heatmaps are efficient to visualize associations between different sources of data sets and reveal potential structures. Here the ComplexHeatmap package provides a highly flexible way to arrange multiple heatmaps and supports self-defined annotation graphics. 1.1 General design A single heatmap is composed of the heatmap body and the heatmap components. The heatmap body can be split by rows and columns. The heatmap components are titles, dendrograms, matrix names and annotations, which are put on the four sides of the heamap body. A heatmap list is concatenation of a list of heatmaps and heatmap annotations. Surrounding the heatmap list, there are global-level titles and legends. One of the important things for the heatmap list is that rows for all heatmaps and annotations (it is row annotation if the heatmap list is horizontal.) are all adusted so that the same row in all heatmaps and annotations corresponds to a same feature. The heatmaps and annotations can also be arranged vertically. The ComplexHeatmap package is implemented in an object-oriented way. To describe a heatmap list, there are following classes: Heatmap class: a single heatmap containing heatmap body, row/column names, titles, dendrograms and column annotations. HeatmapList class: a list of heatmaps and heatmap annotations. HeatmapAnnotation class: defines a list of row annotations and column annotations. The heatmap annotations can be components of heatmap, also they can be independent as heatmaps. There are also several internal classes: SingleAnnotation class: defines a single row annotation or column annotation. ColorMapping class: mapping from values to colors. AnnotationFunction class: construct user-defined annotations. ComplexHeatmap is implemented under grid system, so users need to know basic grid functionality to get full use of the package. 1.2 A brief description of following chapters A Single Heatmap This chapter describes the configurations of a single heatmap. Heatmap Annotations This chapter describes the concept of the heatmap annotation and demonstrates how to make simple annotations as well as complex annotations. Also, the chapter explains the difference between column annotations and row annotations. A List of Heatmaps This chapter describes how to concatenate a list of heatmaps and annotations and how adjustment is applied to keep the correspondence of the heatmaps. Legends This chapter describes how to configurate the heatmap legends and annotation legends, also how to create self-defined legends. Heatmap Decoration This chapter describes methods to add more self-defined graphics to the heatmaps after the heatmaps are generated. OncoPrint This chapter describes how to make oncoPrints and how to integrate other functionalities from ComplexHeatmap to oncoPrints. Other High-level Plots This chapter describes functions implemented in ComplexHeatmap for specific use, e.g. visualizing distributions. More Examples More simulated and real-world examples are shown in this chapter. "],
["a-single-heatmap.html", "Chapter 2 A single Heatmap 2.1 Colors 2.2 Titles 2.3 Clustering 2.4 Row and column orders 2.5 Seriation 2.6 Dimension names 2.7 Heatmap split 2.8 Heatmap as raster image 2.9 Customize the heatmap body 2.10 Size of the heatmap 2.11 Plot the heatmap {plot-the-heatmap} 2.12 Get orders and dendrograms 2.13 Subset a heatmap", " Chapter 2 A single Heatmap A single heatmap is the most used way for visualizing the data. Although “the shining point” of the ComplexHeatmap package is it can visualize a list of heatmaps in parallel, as the basic unit of the heatmap list, it is still very important to have the single heatmap nicely configured. First let’s generate a random matrix where there are three groups by columns and three groups by rows: set.seed(123) nr1 = 4; nr2 = 8; nr3 = 6; nr = nr1 + nr2 + nr3 nc1 = 6; nc2 = 8; nc3 = 10; nc = nc1 + nc2 + nc3 mat = cbind(rbind(matrix(rnorm(nr1*nc1, mean = 1, sd = 0.5), nr = nr1), matrix(rnorm(nr2*nc1, mean = 0, sd = 0.5), nr = nr2), matrix(rnorm(nr3*nc1, mean = 0, sd = 0.5), nr = nr3)), rbind(matrix(rnorm(nr1*nc2, mean = 0, sd = 0.5), nr = nr1), matrix(rnorm(nr2*nc2, mean = 1, sd = 0.5), nr = nr2), matrix(rnorm(nr3*nc2, mean = 0, sd = 0.5), nr = nr3)), rbind(matrix(rnorm(nr1*nc3, mean = 0.5, sd = 0.5), nr = nr1), matrix(rnorm(nr2*nc3, mean = 0.5, sd = 0.5), nr = nr2), matrix(rnorm(nr3*nc3, mean = 1, sd = 0.5), nr = nr3)) ) mat = mat[sample(nr, nr), sample(nc, nc)] # random shuffle rows and columns rownames(mat) = paste0(&quot;row&quot;, seq_len(nr)) colnames(mat) = paste0(&quot;column&quot;, seq_len(nc)) Following command contains the minimal argument for the Heatmap() function which just visualizes the matrix as a heatmap with default settings. Very similar as other heatmap tools, it draws the dendrograms, the row/column names and the heatmap legend. The default color schema is “blue-white-red” which is mapped to the minimal-mean-maximal values in the matrix. The title for the legend is assigned by an internal index number. Heatmap(mat) The title for the legend is taken from the “name” of the heatmap by default. Each heatmap has a name which is like a unique identifier for the heatmap, which is important when you have a list of heatmaps. In later chapters, you will find the heatmap name is used for setting the “main heatmap” and is used for decoration of heatmaps. If the name is not assigned, an internal name is assigned to the heatmap in a form of matrix_%d. In following examples in this chapter, we give the name mat to the heatmap (for which you will see the change of the legend in the next plot). 2.1 Colors For heatmap visualization, colors are the major representation of the data matrix. In most cases, the heatmap visualizes a matrix with continuous numeric values. In this case, users should provide a color mapping function. A color mapping function should accept a vector of values and return a vector of corresponding colors. Users should always use circlize::colorRamp2() function to generate the color mapping function. The two arguments for colorRamp2() is a vector of break values and a vector of corresponding colors. colorRamp2() linearly interpolates colors in every interval through LAB color space. Also using colorRamp2() helps to generate a legend with proper tick marks. In following example, values between -2 and 2 are linearly interpolated to get corresponding colors, values larger than 2 are all mapped to red and values less than -2 are all mapped to green. library(circlize) col_fun = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) col_fun(seq(-3, 3)) ## [1] &quot;#00FF00FF&quot; &quot;#00FF00FF&quot; &quot;#B1FF9AFF&quot; &quot;#FFFFFFFF&quot; &quot;#FF9E81FF&quot; &quot;#FF0000FF&quot; ## [7] &quot;#FF0000FF&quot; Heatmap(mat, name = &quot;mat&quot;, col = col_fun) As you can see, the color mapping function exactly maps negative values to green and positive values to red, even when the distribution of negative values and positive values are not centric to zero. Also this color mapping function is not affected by outliers. In following plot, the clustering is heavily affected by the outlier but not the color mapping. mat2 = mat mat2[1, 1] = 100000 Heatmap(mat2, name = &quot;mat&quot;, col = col_fun) More importantly, colorRamp2() makes colors in multiple heatmaps comparible if they are set with a same color mapping function. If the matrix is continuous, you can simply provide a vector of colors and colors will be linearly interpolated. But remember this method is not robust to outliers because the mapping starts from the minimal value in the matrix and ends with the maximal value. Following color mapping setting is identical to colorRamp2(seq(min(mat), max(mat), length = 10), rev(rainbow(10))). Heatmap(mat, name = &quot;mat&quot;, col = rev(rainbow(10))) If the matrix contains discrete values (either numeric or character), colors should be specified as a named vector to make it possible for the mapping from discrete values to colors. If there is no name for the color, the order of colors corresponds to the order of unique(mat). Note now the legend is generated from the color mapping vector. Following sets colors for a discrete numeric matrix (you don’t need to convert it to a character matrix). discrete_mat = matrix(sample(1:4, 100, replace = TRUE), 10, 10) colors = structure(1:4, names = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;)) # black, red, green, blue Heatmap(discrete_mat, name = &quot;mat&quot;, col = colors) Or a character matrix: discrete_mat = matrix(sample(letters[1:4], 100, replace = TRUE), 10, 10) colors = structure(1:4, names = letters[1:4]) Heatmap(discrete_mat, name = &quot;mat&quot;, col = colors) As you see in the two above examples, for the numeric matrix (no matter the color is continuous mapping or discrete mapping), by default clustering is applied on both dimensions while for character matrix, clustering is turned off (but you can still clustering a character matrix if you provide a proper distance metric for two character vectors, see example in Section 2.3.1). NA is allowed in the matrix. You can control the color of NA by na_col argument (by default it is grey for NA). The matrix that contains NA can also be clustered by Heatmap(). Note the NA value is not presended in the legend. mat_with_na = mat na_index = sample(c(TRUE, FALSE), nrow(mat)*ncol(mat), replace = TRUE, prob = c(1, 9)) mat_with_na[na_index] = NA Heatmap(mat_with_na, name = &quot;mat&quot;, na_col = &quot;black&quot;) Color space is important for interpolating colors. By default, colors are linearly interpolated in LAB color space, but you can select the color space in colorRamp2() function. Compare following two plots. Can you see the difference? f1 = colorRamp2(seq(min(mat), max(mat), length = 3), c(&quot;blue&quot;, &quot;#EEEEEE&quot;, &quot;red&quot;)) f2 = colorRamp2(seq(min(mat), max(mat), length = 3), c(&quot;blue&quot;, &quot;#EEEEEE&quot;, &quot;red&quot;), space = &quot;RGB&quot;) Heatmap(mat, name = &quot;mat1&quot;, col = f1, column_title = &quot;LAB color space&quot;) Heatmap(mat, name = &quot;mat2&quot;, col = f2, column_title = &quot;RGB color space&quot;) In following figures, corresponding values change evenly on the folded lines, you can see how colors change under different color spaces (the plot is made by HilbertCurve package). Last but not the least, colors for the heatmap borders can be set by the border and rect_gp arguments. border controls the global border of the heatmap body and rect_gp controls the border of the grids in the heatmap. The value of border can be logical (TRUE corresponds to black) or a character of color (e.g. red). rect_gp is a gpar object which means you can only set it by grid::gpar(). Since the filled color is already controlled by the heatmap color mapping, you can only set the col parameter in gpar() to control the border of the heatmap grids. Heatmap(mat, name = &quot;mat&quot;, border = TRUE) Heatmap(mat, name = &quot;mat&quot;, rect_gp = gpar(col = &quot;white&quot;, lwd = 2)) 2.2 Titles The title of the heatmap basically tells what the plot is about. In ComplexHeatmap package, you can set heatmap title either by the row or/and by the column. Note at a same time you can only put e.g. column title either on the top or at the bottom of the heatmap. The graphic parameters can be set by row_title_gp and column_title_gp respectively. Please remember you should use gpar() to specify graphic parameters. Heatmap(mat, name = &quot;mat&quot;, column_title = &quot;I am a column title&quot;, row_title = &quot;I am a row title&quot;) Heatmap(mat, name = &quot;mat&quot;, column_title = &quot;I am a column title at the bottom&quot;, column_title_side = &quot;bottom&quot;) Heatmap(mat, name = &quot;mat&quot;, column_title = &quot;I am a big column title&quot;, column_title_gp = gpar(fontsize = 20, fontface = &quot;bold&quot;)) Rotations for titles can be set by row_title_rot and column_title_rot, but only horizontal and vertical rotations are allowed. Heatmap(mat, name = &quot;mat&quot;, row_title = &quot;row title&quot;, row_title_rot = 0) Row or column title supports as a template which is used when rows or columns are split in the heatmap (because there will be multiple row/column titles). This functionality is introduced in Section 2.7. A quick example would be: # code only for demonstration # row title would be cluster_1 and cluster_2 Heatmap(mat, name = &quot;mat&quot;, row_km = 2, row_title = &quot;cluster_%s&quot;) You can set fill parameter in row_title_gp and column_title_gp to set the background color of titles. Heatmap(mat, name = &quot;mat&quot;, column_title = &quot;I am a column title&quot;, column_title_gp = gpar(fill = &quot;red&quot;, col = &quot;white&quot;)) 2.3 Clustering Clustering might be the key component of the heatmap visualization. In ComplexHeatmap package, hierarchical clustering is supported with great flexibility. You can specify the clustering either by: a pre-defined distance method (e.g. &quot;eulidean&quot; or &quot;pearson&quot;), a distance function, a object that already contains clustering (a hclust or dendrogram object or object that can be coerced to hclust or dendrogram class), a clustering function. It is also possible to render the dendrograms with different colors and styles for different branches for better revealing structures of your data (e.g. by dendextend::color_branches()). First, there are general settings for the clustering, e.g. whether apply clustering or show dendrograms, the side of the dendrograms and heights of the dendrograms. Heatmap(mat, name = &quot;mat&quot;, cluster_rows = FALSE) # turn off row clustering Heatmap(mat, name = &quot;mat&quot;, show_column_dend = FALSE) # hide column dendrogram Heatmap(mat, name = &quot;mat&quot;, row_dend_side = &quot;right&quot;, column_dend_side = &quot;bottom&quot;) Heatmap(mat, name = &quot;mat&quot;, column_dend_height = unit(4, &quot;cm&quot;), row_dend_width = unit(4, &quot;cm&quot;)) 2.3.1 Distance methods Hierarchical clustering is performed in two steps: calculate the distance matrix and apply clustering. There are three ways to specify distance metric for clustering: specify distance as a pre-defined option. The valid values are the supported methods in dist() function and in &quot;pearson&quot;, &quot;spearman&quot; and &quot;kendall&quot;. If there is any NA values in the matrix, ComplexHeatmap::dist2() is used instead which performs pairwise distance calculation by removing NA values. The correlation distance is defined as 1 - cor(x, y, method). a self-defined function which calculates distance from a matrix. The function should only contain one argument. Please note for clustering on columns, the matrix will be transposed automatically. a self-defined function which calculates distance from two vectors. The function should only contain two arguments. Heatmap(mat, name = &quot;mat&quot;, clustering_distance_rows = &quot;pearson&quot;, column_title = &quot;pre-defined distance method (1 - pearson)&quot;) Heatmap(mat, name = &quot;mat&quot;, clustering_distance_rows = function(m) dist(m), column_title = &quot;a function that calculates distance matrix&quot;) Heatmap(mat, name = &quot;mat&quot;, clustering_distance_rows = function(x, y) 1 - cor(x, y), column_title = &quot;a function that calculates pairwise distance&quot;) Based on these features, we can apply clustering which is robust to outliers based on the pairwise distance. Note here we set the color mapping function because we don’t want outliers affect the colors. mat_with_outliers = mat for(i in 1:10) mat_with_outliers[i, i] = 1000 robust_dist = function(x, y) { qx = quantile(x, c(0.1, 0.9)) qy = quantile(y, c(0.1, 0.9)) l = x &gt; qx[1] &amp; x &lt; qx[2] &amp; y &gt; qy[1] &amp; y &lt; qy[2] x = x[l] y = y[l] sqrt(sum((x - y)^2)) } and we compare the two heatmaps with or without the robust distance method: Heatmap(mat_with_outliers, name = &quot;mat&quot;, col = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)), column_title = &quot;dist&quot;) Heatmap(mat_with_outliers, name = &quot;mat&quot;, col = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)), clustering_distance_rows = robust_dist, clustering_distance_columns = robust_dist, column_title = &quot;robust_dist&quot;) If there are proper distance methods (like methods in stringdist package, you can also cluster a character matrix. cell_fun argument will be introduced in Section 2.9. mat_letters = matrix(sample(letters[1:4], 100, replace = TRUE), 10) # distance in the ASCII table dist_letters = function(x, y) { x = strtoi(charToRaw(paste(x, collapse = &quot;&quot;)), base = 16) y = strtoi(charToRaw(paste(y, collapse = &quot;&quot;)), base = 16) sqrt(sum((x - y)^2)) } Heatmap(mat_letters, name = &quot;letters&quot;, col = structure(2:5, names = letters[1:4]), clustering_distance_rows = dist_letters, clustering_distance_columns = dist_letters, cell_fun = function(j, i, x, y, w, h, col) { # add text to each grid grid.text(mat_letters[i, j], x, y) }) 2.3.2 Clustering methods Method to perform hierarchical clustering can be specified by clustering_method_rows and clustering_method_columns. Possible methods are those supported in hclust() function. Heatmap(mat, name = &quot;mat&quot;, clustering_method_rows = &quot;single&quot;) If you already have clustering objects or a function which directly returns a clustering object, you can ignore the distance settings and set cluster_rows or cluster_columns to the clustering objects or clustering functions. If it is a clustering function, the only argument should be the matrix and it should return a hclust or dendrogram object or a object that can be coerced to the two classes. In following example, we perform clustering with methods from cluster package either by a pre-calculated clustering object or a clustering function: library(cluster) Heatmap(mat, name = &quot;mat&quot;, cluster_rows = as.dendrogram(diana(mat)), cluster_columns = as.dendrogram(agnes(t(mat))), column_title = &quot;clustering objects&quot;) Heatmap(mat, name = &quot;mat&quot;, cluster_rows = diana, cluster_columns = agnes, column_title = &quot;clustering functions&quot;) The last command is as same as : # code only for demonstration Heatmap(mat, name = &quot;mat&quot;, cluster_rows = function(m) as.dendrogram(diana(m)), cluster_columns = function(m) as.dendrogram(agnes(m)), column_title = &quot;clutering functions&quot;) Please note, when cluster_rows is set as a function, the argument m is the input mat itself, while for cluster_columns, m is the transpose of mat. fastcluster::hclust implements a faster version of hclust(). We can set it to cluster_rows and cluster_columns to use the faster version of hclust(). # code only for demonstration Heatmap(mat, name = &quot;mat&quot;, cluster_rows = fastcluster::hclust, cluster_columns = fastcluster::hclust) To make it more convinient to use the faster version of hclust() (assuming you have many heatmaps to construct), it can be set as a global option. The usage of ht_opt is introduced in Section 4.11. # code not run when building the vignette ht_opt$fast_hclust = TRUE # now fastcluster::hclust is used in all heatmaps 2.3.3 Render dendrograms If you want to render the dendrogram, normally you need to generate a dendrogram object and render it in the first place, then send it to the cluster_rows or cluster_columns argument. You can render your dendrogram object by the dendextend package to make a more customized visualization of the dendrogram. Note ComplexHeatmap only allows rendering on the dendrogram edges. library(dendextend) row_dend = as.dendrogram(hclust(dist(mat))) row_dend = color_branches(row_dend, k = 2) # `color_branches()` returns a dendrogram object Heatmap(mat, name = &quot;mat&quot;, cluster_rows = row_dend) 2.3.4 Reorder dendrograms In the Heatmap() function, dendrograms are reordered to make features with larger difference more separated from each others (please refer to the documentation of reorder.dendrogram()). Here the difference (or it is called the weight) is measured by the row means if it is a row dendrogram or by the column means if it is a column dendrogram. row_dend_reorder and column_dend_reorder control whether to apply dendrogram reordering If they are set to TRUE or FALSE, ot they control the weight for the reordering if they are set to numeric vectors (send to the wts argument of reorder.dendrogram()). The reordering can be turned off by setting e.g. row_dend_reorder = FALSE. There are many other methods for reordering dendrograms, e.g. the dendsort package. Basically, all these methods still return a dendrogram that has been reordered, thus, we can firstly generate the row or column dendrogram based on the data matrix, reorder it by some method, and assign it back to cluster_rows or cluster_columns. Compare following three heatmaps: Heatmap(mat, name = &quot;mat&quot;, row_dend_reorder = FALSE, column_title = &quot;no reordering&quot;) Heatmap(mat, name = &quot;mat&quot;, row_dend_reorder = TRUE, column_title = &quot;applied reordering&quot;) library(dendsort) dend = dendsort(as.dendrogram(hclust(dist(mat)))) Heatmap(mat, name = &quot;mat&quot;, cluster_rows = dend, row_dend_reorder = FALSE, column_title = &quot;reordering by dendsort&quot;) 2.4 Row and column orders Clustering is used to adjust row orders and column orders of the heatmap, but you can still set the order manually by row_order and column_order. If e.g. row_order is set, row clustering is turned off. Heatmap(mat, name = &quot;mat&quot;, row_order = order(rownames(mat)), column_order = order(colnames(mat))) Note row_dend_reorder and row_order are two different things. row_dend_reorder is applied on the dendrogram. For any node in the dendrogram, rotating its two branches actually gives an identical dendrogram, thus, reordering the dendrogram by automatically rotating sub-dendrogram at every node can help to separate elements further from each other which show more difference. As a comparison, row_order is simply applied on the matrix and normally dendrograms should be turned off. 2.5 Seriation Seriation is an interesting technique for ordering the matrix (see this interesting post: http://nicolas.kruchten.com/content/2018/02/seriation/). The powerful seriation package implements quite a lot of methods for seriation. Since it is easy to extract row orders and column ordes from the object returned by the core function seriate() from seriation package. They can be directly assigned to row_order and column_order to make the heatmap. The first example demonstrates to directly apply seriate() on the matrix. Since the &quot;BEA_TSP&quot; method only allows a non-negative matrix, we modify the matrix to max(mat) - mat. library(seriation) o = seriate(max(mat) - mat, method = &quot;BEA_TSP&quot;) Heatmap(max(mat) - mat, name = &quot;mat&quot;, row_order = get_order(o, 1), column_order = get_order(o, 2)) Or apply seriate() to the distance matrix. Now the order for rows and columns needs to be calcualted separatedly (because the distance matrix needs to be calculated separatedly). o1 = seriate(dist(mat), method = &quot;TSP&quot;) o2 = seriate(dist(t(mat)), method = &quot;TSP&quot;) Heatmap(mat, name = &quot;mat&quot;, row_order = get_order(o1), column_order = get_order(o2)) Some seriation methods also contain the hierarchical clustering information. Let’s try: o1 = seriate(dist(mat), method = &quot;GW&quot;) o2 = seriate(dist(t(mat)), method = &quot;GW&quot;) o1 and o2 are actually mainly composed of hclust objects: class(o1[[1]]) ## [1] &quot;ser_permutation_vector&quot; &quot;hclust&quot; And the orders are the same by using hclust$order or get_order(). o1[[1]]$order ## [1] 1 2 11 12 5 15 16 17 7 8 6 9 10 18 13 4 3 14 # should be the same as the previous one get_order(o1) ## [1] 1 2 11 12 5 15 16 17 7 8 6 9 10 18 13 4 3 14 And we can add the dendrograms to the heatmap (note here we turned off the default reordering because we exactly want the dendrogram order returned from seriation). Heatmap(mat, cluster_rows = as.dendrogram(o1[[1]]), row_dend_reorder = FALSE, cluster_columns = as.dendrogram(o2[[1]]), column_dend_reorder = FALSE) For more use of the seriate() function, please refer to the seriation package. 2.6 Dimension names The row names and column names are drawn on the right and bottom sides of the heatmap by default. Side, visibility and graphic parameters for dimension names can be set as follows: Heatmap(mat, name = &quot;mat&quot;, row_names_side = &quot;left&quot;, row_dend_side = &quot;right&quot;, column_names_side = &quot;top&quot;, column_dend_side = &quot;bottom&quot;) Heatmap(mat, name = &quot;mat&quot;, show_row_names = FALSE) Heatmap(mat, name = &quot;mat&quot;, row_names_gp = gpar(fontsize = 20)) Heatmap(mat, name = &quot;mat&quot;, row_names_gp = gpar(col = c(rep(&quot;red&quot;, 10), rep(&quot;blue&quot;, 8)))) The rotation of column names can be set by column_names_rot: Heatmap(mat, name = &quot;mat&quot;, column_names_rot = 45) Heatmap(mat, name = &quot;mat&quot;, column_names_rot = 45, column_names_side = &quot;top&quot;, column_dend_side = &quot;bottom&quot;) If you have row names or column names which are too long, row_names_max_width or column_names_max_height can be used to set the maximal space for them. Instead of directly using the row/column names from the matrix, you can also provide another character vector which corresponds to the rows or columns and set it by row_labels or column_labels. This is useful because you don’t need to change the dimension names of the matrix to change the labels on the heatmap while you can directly provide the new labels. There is one typical scenario that row_labels and column_labels are useful. For the gene expression analysis, we might use Ensembl ID as the gene ID which is used as row names of the gene expression matrix. However, the Ensembl ID is for the indexing of the Ensembl database but not for the human reading. Instead, we would prefer to put gene symbol on the heatmap as the row names which is easier to read. To do this, we only need to assign the corresponding gene symbols to row_labels without modifying the original matrix. Another advantage is row_labels or column_labels allows duplicated labels, while duplicated row names or column names are not allowed in the matrix. Following gives a simple example that we put letters as row labels and column labels: # use named vectors to make sure the correspondance between row names and row labels is correct row_labels = structure(paste0(letters[1:24], 1:24), names = paste0(&quot;row&quot;, 1:24)) column_labels = structure(paste0(LETTERS[1:24], 1:24), names = paste0(&quot;column&quot;, 1:24)) row_labels ## row1 row2 row3 row4 row5 row6 row7 row8 row9 row10 row11 row12 ## &quot;a1&quot; &quot;b2&quot; &quot;c3&quot; &quot;d4&quot; &quot;e5&quot; &quot;f6&quot; &quot;g7&quot; &quot;h8&quot; &quot;i9&quot; &quot;j10&quot; &quot;k11&quot; &quot;l12&quot; ## row13 row14 row15 row16 row17 row18 row19 row20 row21 row22 row23 row24 ## &quot;m13&quot; &quot;n14&quot; &quot;o15&quot; &quot;p16&quot; &quot;q17&quot; &quot;r18&quot; &quot;s19&quot; &quot;t20&quot; &quot;u21&quot; &quot;v22&quot; &quot;w23&quot; &quot;x24&quot; Heatmap(mat, name = &quot;mat&quot;, row_labels = row_labels[rownames(mat)], column_labels = column_labels[colnames(mat)]) 2.7 Heatmap split One major advantage of ComplexHeatmap package is it supports splitting the heatmap by rows or/and by columns to better group the features and additionally highlight the patterns. Following arguments control the splitting: row_km, row_split, column_km, column_split. In following, we call the sub-clusters generated by splitting “slices”. 2.7.1 Split by k-means clustering row_km and column_km apply k-means partitioning. Heatmap(mat, name = &quot;mat&quot;, row_km = 2) Heatmap(mat, name = &quot;mat&quot;, column_km = 3) Row splitting and column splitting can be performed simultaneously. Heatmap(mat, name = &quot;mat&quot;, row_km = 2, column_km = 3) 2.7.2 Split by categorical variables More generally, row_split or column_split can be set to a categorical vector or a data frame where different combinations of levels split the rows/columns in the heatmap. The order of each slice can be controlled by levels of each variable in split (in this case, each variable should be a factor). If all variables are characters, the default order is unique(row_split) or unique(column_split). Heatmap(mat, name = &quot;mat&quot;, row_split = rep(c(&quot;A&quot;, &quot;B&quot;), 9), column_split = rep(c(&quot;C&quot;, &quot;D&quot;), 12)) Heatmap(mat, name = &quot;mat&quot;, row_split = data.frame(rep(c(&quot;A&quot;, &quot;B&quot;), 9), rep(c(&quot;C&quot;, &quot;D&quot;), each = 9))) Heatmap(mat, name = &quot;mat&quot;, row_split = factor(rep(c(&quot;A&quot;, &quot;B&quot;), 9), levels = c(&quot;B&quot;, &quot;A&quot;)), column_split = factor(rep(c(&quot;C&quot;, &quot;D&quot;), 12), levels = c(&quot;D&quot;, &quot;C&quot;))) Actually, k-means clustering just generates a vector of cluster classes and appends to row_split or column_split. row_km/column_km and be used mixed with row_split and column_split. Heatmap(mat, name = &quot;mat&quot;, row_split = rep(c(&quot;A&quot;, &quot;B&quot;), 9), row_km = 2) which is as the same as: # code only for demonstration cl = kmeans(mat, centers = 2)$cluster # classes from k-means are always put as the first column in `row_split` Heatmap(mat, name = &quot;mat&quot;, row_split = cbind(cl, rep(c(&quot;A&quot;, &quot;B&quot;), 9))) If you are not happy with the default k-means partition, it is easy to use other partition methods by just assigning the partition vector to row_split/column_split. pa = pam(mat, k = 3) Heatmap(mat, name = &quot;mat&quot;, row_split = paste0(&quot;pam&quot;, pa$clustering)) If row_order or column_order is set, in each row/column slice, it is still ordered. # remember when `row_order` is set, hierarchical clustering on rows is turned off Heatmap(mat, name = &quot;mat&quot;, row_order = 18:1, row_km = 2) Character matrix can only be split by row_split/column_split argument. # split by the first column in `discrete_mat` Heatmap(discrete_mat, name = &quot;mat&quot;, col = 1:4, row_split = discrete_mat[, 1]) 2.7.3 Split by dendrogram In the scenarios described previously, if row_km/column_km is set or row_split/column_split is set as a vector or a data frame, hierarchical clustering is first applied to each slice which generates k dendrograms, then a parent dendrogram is generated based on the mean value of each slice. The height of the parent dendrogram is adjusted by adding the maximal height of the dendrograms in all children slices and the parent dendrogram is added on top of the children dendrograms to form a single global dendrogram. A second scenario for splitting is that users may still want to keep the global dendrogram which is generated from the complete matrix while not split it in the first place. In this case, row_split/column_split can be set to a single number which will apply cutree() on the row/column dendrogram. This works when cluster_rows/cluster_columns is set to TRUE or is assigned with a hclust/dendrogram object. For this case, the dendrogram is still as same as the original one, expect the positions of dendrogram leaves are slightly adjusted by the gaps between slices. Heatmap(mat, name = &quot;mat&quot;, row_split = 2, column_split = 3) dend = hclust(dist(mat)) dend = color_branches(dend, k = 2) Heatmap(mat, name = &quot;mat&quot;, cluster_rows = dend, row_split = 2) If you want to combine splitting from cutree() and other categorical variables, you need to generate the classes from cutree() in the first place, append to e.g. row_split as a data frame and then send it to row_split argument. # code only for demonstration split = data.frame(cutree(hclust(dist(mat)), k = 2), rep(c(&quot;A&quot;, &quot;B&quot;), 9)) Heatmap(mat, name = &quot;mat&quot;, row_split = split) 2.7.4 Titles for splitting When row_split/column_split is set as a single number, there is only one categorical variable, while when row_km/column_km is set and/or row_split/column_split is set as categorical variables, there will be multiple categorical variables. By default, the titlea are in a form of &quot;level1,level2,...&quot; which corresponds to every combination of levels in all categorical variables. The titles for splitting can be controlled by “a title template”. ComplexHeatmap supports three types of templates. The first one is by sprintf() where the %s is replaced by the corresponding level. In following example, since all combinations of split are A,C, A,D, B,C and B,D, if row_title is set to %s|%s, the four row titles will be A|C, A|D, B|C, B|D. split = data.frame(rep(c(&quot;A&quot;, &quot;B&quot;), 9), rep(c(&quot;C&quot;, &quot;D&quot;), each = 9)) Heatmap(mat, name = &quot;mat&quot;, row_split = split, row_title = &quot;%s|%s&quot;) For the sprintf() template, you can only put the levels which are A,B,C,D in the title. However, when making the heatmap, you might want to put more meaningful text instead of the internal levels. Once you know how to correspond the text to the level, you can add it by following two template methods. In the following two template methods, special marks are used to mark the R code which is executable (it is called variable interpolation where the code is extracted and executed and the returned value in put back to the string). There are two types of template marks @{} and {}. The first one is from GetoptLong package which should already be installed when you install the ComplexHeatmap package and the second one is from glue package which you need to install to support it. There is an internal variable x you should use when you use the latter two templates. x is just a simple vector which contains current category levels (e.g. c(&quot;A&quot;, &quot;C&quot;)). # code only for demonstration map = c(&quot;A&quot; = &quot;aaa&quot;, &quot;B&quot; = &quot;bbb&quot;, &quot;C&quot; = &quot;333&quot;, &quot;D&quot; = &quot;444&quot;) Heatmap(mat, name = &quot;mat&quot;, row_split = split, row_title = &quot;@{map[ x[1] ]}|@{map[ x[2] ]}&quot;) Heatmap(mat, name = &quot;mat&quot;, row_split = split, row_title = &quot;{map[ x[1] ]}|{map[ x[2] ]}&quot;) The row title is rotated by default, you can set row_title_rot = 0 to make it horizontal: Heatmap(mat, name = &quot;mat&quot;, row_split = split, row_title = &quot;%s|%s&quot;, row_title_rot = 0) When row_split/column_split is set as a number, you can also use template to adjust the titles for slices. Heatmap(mat, name = &quot;mat&quot;, row_split = 2, row_title = &quot;cluster_%s&quot;) If you know the final number of row slices, you can directly set a vector of titles to row_title. Be careful the number of row slices is not always identical to nlevel_1*nlevel_2*.... Heatmap(mat, name = &quot;mat&quot;, row_split = split, row_title = c(&quot;top_slice&quot;, &quot;middle_top_slice&quot;, &quot;middle_bottom_slice&quot;, &quot;bottom_slice&quot;), row_title_rot = 0) If the length of row_title is specified as a single string, it will be like a title for all slices. Heatmap(mat, name = &quot;mat&quot;, row_split = split, row_title = &quot;there are four slices&quot;) If you still want titles for each slice, but also a global title, you can do as follows. ht = Heatmap(mat, name = &quot;mat&quot;, row_split = split, row_title = &quot;%s|%s&quot;) draw(ht, row_title = &quot;I am a row title&quot;) Actually the row_title used in draw() function is the row title of the heatmap list, although in the example there is only one heatmap. The draw() function and the heatmap list will be introduced in Chapter 4. If row_title is set to NULL or &quot;&quot;, no row title will be drawn. Heatmap(mat, name = &quot;mat&quot;, row_split = split, row_title = NULL) 2.7.5 Graphic parameters for splitting When splitting is applied on rows/columns, graphic parameters for row/column title and row/column names can be specified as same length as number of slices. Heatmap(mat, name = &quot;mat&quot;, row_km = 2, row_title_gp = gpar(col = c(&quot;red&quot;, &quot;blue&quot;), font = 1:2), row_names_gp = gpar(col = c(&quot;green&quot;, &quot;orange&quot;), fontsize = c(10, 14)), column_km = 3, column_title_gp = gpar(col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), font = 1:3), column_names_gp = gpar(col = c(&quot;green&quot;, &quot;orange&quot;, &quot;purple&quot;), fontsize = c(10, 14, 8))) 2.7.6 Gaps between slices The space of gaps between row/column slices can be controlled by row_gap/column_gap. The value can be a single unit or a vector of units. Heatmap(mat, name = &quot;mat&quot;, row_km = 3, row_gap = unit(5, &quot;mm&quot;)) Heatmap(mat, name = &quot;mat&quot;, row_km = 3, row_gap = unit(c(2, 4), &quot;mm&quot;)) Heatmap(mat, name = &quot;mat&quot;, row_km = 3, row_gap = unit(c(2, 4), &quot;mm&quot;), column_km = 3, column_gap = unit(c(2, 4), &quot;mm&quot;)) When heatmap border is added by setting border = TRUE, the border of every slice is added. Heatmap(mat, name = &quot;mat&quot;, row_km = 2, column_km = 3, border = TRUE) If you set gap size to zero, the heatmap will look like it is partitioned by vertical and horizontal lines. Heatmap(mat, name = &quot;mat&quot;, row_km = 2, column_km = 3, row_gap = unit(0, &quot;mm&quot;), column_gap = unit(0, &quot;mm&quot;), border = TRUE) 2.7.7 Split heatmap annotations When the heatmap is split, all the heatmap components are split accordingly. Following gives you a simple example and the heatmap annotation will be introduced in Chapter ??. Heatmap(mat, name = &quot;mat&quot;, row_km = 2, column_km = 3, top_annotation = HeatmapAnnotation(foo1 = 1:24, bar1 = anno_points(runif(24))), right_annotation = rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18))) ) 2.8 Heatmap as raster image Saving plots in PDF format is kind like best parctice to preserve the quality. However, when there are too many rows (say, &gt; 10000), the output PDF file would be huge and it takes long time and memory to read the whole plot. On the other hand, details of the huge matrix will not be seen in limited size of PDF file. Rendering heatmaps (the heatmap body) as raster images will effectively reduce the file size while the plot looks exactly the same for your screen or if you print it out. In Heatmap() function, there are four options which control how to generate the raster image: use_raster, raster_device, raster_quality, raster_device_param. You can choose graphic device (png, jpeg and tiff) by raster_device, control the quality of the raster image by raster_quality, and pass further parameters for a specific device by raster_device_param. If raster_quality is set to 1, internally, a PNG (if raster_device is set to png) file is generated with the same physical size as the heatmap body and refit into the heatmap body as a raster image. The png file generated has the size of raster_quality*width and raster_quality*height. So a larger raster_quality value gives you a better reservation of the original resolution. In Complexheatmap, use_raster is by default turned on if the number of rows or columns is more than 2000. # code only for demonstration Heatmap(mat, use_raster = TRUE, raster_quality = 2) 2.9 Customize the heatmap body The heatmap body can be self-defined to add more types of graphics. By default the heatmap body is composed by an array of rectangles (it might be called grids in other parts of this documentation, but it is called “cells” here) with different filled colors. However, it is also possible to add more graphics or symbols as additional layers on the heatmap. There are two arguments cell_fun and layer_fun which both should be user-defined functions. cell_fun draws in each cell repeatedly, which is internally executed in two nested for loops, while layer_fun is the vectorized version of cell_fun. cell_fun is easier to understand but layer_fun is faster to execute. cell_fun expects a function with 7 arguments (the argument names can be different from following, but the order must be the same), which are: j: column index in the matrix. Column index corresponds to the x-direction in the viewport, that’s why j is put as the first argument. i: row index in the matrix. x: x coordinate of middle point of the cell which is measured in the viewport of the heatmap body. y: y coordinate of middle point of the cell which is measured in the viewport of the heatmap body. width: width of the cell. The value is unit(1/ncol(mat), &quot;npc&quot;). height: height of the cell. The value is unit(1/nrow(mat), &quot;npc&quot;). fill: color of the cell. The values for the seven arguments are automatically sent to the function when executed in each cell. The most common use is to add values in the matrix onto the heatmap: small_mat = mat[1:9, 1:9] col_fun = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) Heatmap(small_mat, name = &quot;mat&quot;, col = col_fun, cell_fun = function(j, i, x, y, width, height, fill) { grid.text(sprintf(&quot;%.1f&quot;, mat[i, j]), x, y, gp = gpar(fontsize = 10)) }) and we can also choose only to add text for the cells with positive values: Heatmap(small_mat, name = &quot;mat&quot;, col = col_fun, cell_fun = function(j, i, x, y, width, height, fill) { if(small_mat[i, j] &gt; 0) grid.text(sprintf(&quot;%.1f&quot;, mat[i, j]), x, y, gp = gpar(fontsize = 10)) }) In following example, we make a heatmap which shows correlation matrix similar as the corrplot package: cor_mat = cor(small_mat) od = hclust(dist(cor_mat))$order cor_mat = cor_mat[od, od] nm = rownames(cor_mat) col_fun = circlize::colorRamp2(c(-1, 0, 1), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) # `col = col_fun` here is used to generate the legend Heatmap(cor_mat, name = &quot;correlation&quot;, col = col_fun, rect_gp = gpar(type = &quot;none&quot;), cell_fun = function(j, i, x, y, width, height, fill) { grid.rect(x = x, y = y, width = width, height = height, gp = gpar(col = &quot;grey&quot;, fill = NA)) if(i == j) { grid.text(nm[i], x = x, y = y) } else if(i &gt; j) { grid.circle(x = x, y = y, r = abs(cor_mat[i, j])/2 * min(unit.c(width, height)), gp = gpar(fill = col_fun(cor_mat[i, j]), col = NA)) } else { grid.text(sprintf(&quot;%.1f&quot;, cor_mat[i, j]), x, y, gp = gpar(fontsize = 10)) } }, cluster_rows = FALSE, cluster_columns = FALSE, show_row_names = FALSE, show_column_names = FALSE) As you may see, when setting the non-standard parameter rect_gp = gpar(type = &quot;none&quot;), the clustering is performed but nothing is drawn on the heatmap body. Similar as cell_fun, layer_fun also needs seven arguments, but they are all in vector form: # code only for demonstration Heatmap(..., layer_fun = function(j, i, x, y, w, h, fill) {...}) # on you can capitalize the arguments to mark they are vectors Heatmap(..., layer_fun = function(J, I, X, Y, W, H, F) {...}) Since j and i are vectors, to get corresponding values in the matrix, we cannot use the form as mat[j, i] because it gives you a sub-matrix with length(i) rows and length(j) columns, instead we can use pindex() function from ComplexHeatmap which is like pairwise indexing. See follow example: mfoo = matrix(1:9, nr = 3) mfoo[1:2, c(1, 3)] ## [,1] [,2] ## [1,] 1 7 ## [2,] 2 8 # but we actually want mfoo[1, 1] and mfoo[2, 3] pindex(mfoo, 1:2, c(1, 3)) ## [1] 1 8 Next example shows the layer_fun version of adding text on heatmap. It’s basically the same as the cell_fun version. col_fun = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) Heatmap(small_mat, name = &quot;mat&quot;, col = col_fun, layer_fun = function(j, i, x, y, width, height, fill) { # since grid.text can also be vectorized grid.text(sprintf(&quot;%.1f&quot;, pindex(mat, i, j)), x, y, gp = gpar(fontsize = 10)) }) And only add text to cells with positive values: Heatmap(small_mat, name = &quot;mat&quot;, col = col_fun, layer_fun = function(j, i, x, y, width, height, fill) { v = pindex(mat, i, j) l = v &gt; 0 grid.text(sprintf(&quot;%.1f&quot;, v[l]), x[l], y[l], gp = gpar(fontsize = 10)) }) One last example is to visualize a GO game. The input data takes records of moves in the game. str = &quot;B[cp];W[pq];B[dc];W[qd];B[eq];W[od];B[de];W[jc];B[qk];W[qn] ;B[qh];W[ck];B[ci];W[cn];B[hc];W[je];B[jq];W[df];B[ee];W[cf] ;B[ei];W[bc];B[ce];W[be];B[bd];W[cd];B[bf];W[ad];B[bg];W[cc] ;B[eb];W[db];B[ec];W[lq];B[nq];W[jp];B[iq];W[kq];B[pp];W[op] ;B[po];W[oq];B[rp];W[ql];B[oo];W[no];B[pl];W[pm];B[np];W[qq] ;B[om];W[ol];B[pk];W[qp];B[on];W[rm];B[mo];W[nr];B[rl];W[rk] ;B[qm];W[dp];B[dq];W[ql];B[or];W[mp];B[nn];W[mq];B[qm];W[bp] ;B[co];W[ql];B[no];W[pr];B[qm];W[dd];B[pn];W[ed];B[bo];W[eg] ;B[ef];W[dg];B[ge];W[gh];B[gf];W[gg];B[ek];W[ig];B[fd];W[en] ;B[bn];W[ip];B[dm];W[ff];B[cb];W[fe];B[hp];W[ho];B[hq];W[el] ;B[dl];W[fk];B[ej];W[fp];B[go];W[hn];B[fo];W[em];B[dn];W[eo] ;B[gp];W[ib];B[gc];W[pg];B[qg];W[ng];B[qc];W[re];B[pf];W[of] ;B[rc];W[ob];B[ph];W[qo];B[rn];W[mi];B[og];W[oe];B[qe];W[rd] ;B[rf];W[pd];B[gm];W[gl];B[fm];W[fl];B[lj];W[mj];B[lk];W[ro] ;B[hl];W[hk];B[ik];W[dk];B[bi];W[di];B[dj];W[dh];B[hj];W[gj] ;B[li];W[lh];B[kh];W[lg];B[jn];W[do];B[cl];W[ij];B[gk];W[bl] ;B[cm];W[hk];B[jk];W[lo];B[hi];W[hm];B[gk];W[bm];B[cn];W[hk] ;B[il];W[cq];B[bq];W[ii];B[sm];W[jo];B[kn];W[fq];B[ep];W[cj] ;B[bk];W[er];B[cr];W[gr];B[gk];W[fj];B[ko];W[kp];B[hr];W[jr] ;B[nh];W[mh];B[mk];W[bb];B[da];W[jh];B[ic];W[id];B[hb];W[jb] ;B[oj];W[fn];B[fs];W[fr];B[gs];W[es];B[hs];W[gn];B[kr];W[is] ;B[dr];W[fi];B[bj];W[hd];B[gd];W[ln];B[lm];W[oi];B[oh];W[ni] ;B[pi];W[ki];B[kj];W[ji];B[so];W[rq];B[if];W[jf];B[hh];W[hf] ;B[he];W[ie];B[hg];W[ba];B[ca];W[sp];B[im];W[sn];B[rm];W[pe] ;B[qf];W[if];B[hk];W[nj];B[nk];W[lr];B[mn];W[af];B[ag];W[ch] ;B[bh];W[lp];B[ia];W[ja];B[ha];W[sf];B[sg];W[se];B[eh];W[fh] ;B[in];W[ih];B[ae];W[so];B[af]&quot; We convert it into a matrix: str = gsub(&quot;\\\\n&quot;, &quot;&quot;, str) step = strsplit(str, &quot;;&quot;)[[1]] type = gsub(&quot;(B|W).*&quot;, &quot;\\\\1&quot;, step) row = gsub(&quot;(B|W)\\\\[(.).\\\\]&quot;, &quot;\\\\2&quot;, step) column = gsub(&quot;(B|W)\\\\[.(.)\\\\]&quot;, &quot;\\\\2&quot;, step) go_mat = matrix(nrow = 19, ncol = 19) rownames(go_mat) = letters[1:19] colnames(go_mat) = letters[1:19] for(i in seq_along(row)) { go_mat[row[i], column[i]] = type[i] } go_mat[1:4, 1:4] ## a b c d ## a NA NA NA &quot;W&quot; ## b &quot;W&quot; &quot;W&quot; &quot;W&quot; &quot;B&quot; ## c &quot;B&quot; &quot;B&quot; &quot;W&quot; &quot;W&quot; ## d &quot;B&quot; &quot;W&quot; &quot;B&quot; &quot;W&quot; Black and white stones are put based on the values in the matrix: Heatmap(go_mat, name = &quot;go&quot;, rect_gp = gpar(type = &quot;none&quot;), cell_fun = function(j, i, x, y, w, h, col) { grid.rect(x, y, w, h, gp = gpar(fill = &quot;#dcb35c&quot;, col = NA)) if(i == 1) { grid.segments(x, y-h*0.5, x, y) } else if(i == nrow(go_mat)) { grid.segments(x, y, x, y+h*0.5) } else { grid.segments(x, y-h*0.5, x, y+h*0.5) } if(j == 1) { grid.segments(x, y, x+w*0.5, y) } else if(j == ncol(go_mat)) { grid.segments(x-w*0.5, y, x, y) } else { grid.segments(x-w*0.5, y, x+w*0.5, y) } if(i %in% c(4, 10, 16) &amp; j %in% c(4, 10, 16)) { grid.points(x, y, pch = 16, size = unit(2, &quot;mm&quot;)) } r = min(unit.c(w, h))*0.45 if(is.na(go_mat[i, j])) { } else if(go_mat[i, j] == &quot;W&quot;) { grid.circle(x, y, r, gp = gpar(fill = &quot;white&quot;, col = &quot;white&quot;)) } else if(go_mat[i, j] == &quot;B&quot;) { grid.circle(x, y, r, gp = gpar(fill = &quot;black&quot;, col = &quot;black&quot;)) } }, col = c(&quot;B&quot; = &quot;black&quot;, &quot;W&quot; = &quot;white&quot;), show_row_names = FALSE, show_column_names = FALSE, column_title = &quot;One famous GO game&quot;, heatmap_legend_param = list(title = &quot;Player&quot;, at = c(&quot;B&quot;, &quot;W&quot;), labels = c(&quot;player1&quot;, &quot;player2&quot;), border = &quot;black&quot;) ) 2.10 Size of the heatmap width, heatmap_width, height and heatmap_height control the size of the heatmap. By default, all heatmap components have fixed width or height, e.g. the width of row dendrogram is 1cm. The width or the height of the heatmap body fill the rest area of the final plotting region, which means, if you draw it in an interactive graphic window and you change the size of the window by draging it, the size of the heatmap body is automatically adjusted. heatmap_width and heatmap_height control the width/height of the complete heatmap while width and height only control the width/height of the heamtap body. All these four arguments can be set as absolute units. Heatmap(mat, name = &quot;mat&quot;, width = unit(10, &quot;cm&quot;), height = unit(10, &quot;cm&quot;)) ## Since all heatmaps/annotations have absolute units, the total width of the plot is 138mm ## Since all heatmaps/annotations have absolute units, the total height of the plot is 135mm Heatmap(mat, name = &quot;mat&quot;, heatmap_width = unit(10, &quot;cm&quot;), heatmap_height = unit(10, &quot;cm&quot;)) ## Since all heatmaps/annotations have absolute units, the total width of the plot is 114mm ## Since all heatmaps/annotations have absolute units, the total height of the plot is 104mm There will be message showing the size of the whole plot. These four arguments are more important when adjust the size in a list of heatmaps (see Section 4.2). 2.11 Plot the heatmap {plot-the-heatmap} Heatmap() function actually is only a constructor, which means it only puts all the data and configurations into the object in the Heatmap class. The clustering will only be performed when the draw() method is called. Under interactive mode (e.g. the interactive R terminal where you can type your R code line by line), directly calling Heatmap() without returning to any object prints the object and the print method (or the S4 show() method) for the Heatmap class object calls draw() internally. So if you type Heatmap(...) in your R terminal, it looks like it is a plotting function like plot(), you need to be aware of that it is actually not true and in the following cases you might see nothing plotted. you put Heatmap(...) inside a function, you put Heatmap(...) in a code chunk like for or if-else you put Heatmap(...) in an Rscript and you run it under command line. The reason is in above three cases, the show() method WILL NOT be called and thus draw() method is not executed either. So, to make the plot, you need to call draw() explicitly: draw(Heatmap(...)) or: # code only for demonstration ht = Heatmap(...) draw(ht) The draw() function actually is applied to a list of heatmaps in HeatmapList class. The draw() method for the single Heatmap class constructs a HeatmapList with only one heatmap and call draw() method of the HeatmapList class. The draw() function accpets a lot of more arguments which e.g. controls the legends. It will be discussed in Chapter 4. draw(ht, heatmap_legend_side, padding, ...) 2.12 Get orders and dendrograms The row/column orders of the heatmap can be obtained by row_order()/column_order() functions. You can directly apply to the heatmap object returned by Heatmap() or to the object returned by draw(). In following, we take row_order() as example. small_mat = mat[1:9, 1:9] ht1 = Heatmap(small_mat) row_order(ht1) ## [1] 9 6 7 8 3 4 2 5 1 ht2 = draw(ht1) row_order(ht2) ## [1] 9 6 7 8 3 4 2 5 1 As explained in previous section, Heatmap() function does not perform clustering, thus, when directly apply row_order() on ht1, clustering will be performed. Later when making the heatmap by draw(ht1), the clustering will be applied again. This might be a problem that if you set k-means clustering in the heatmap. Since the clustering is applied twice, k-means might give you different clustering, which means, you might have different results from row_order() and you might have different heatmap. In following chunk of code, o1, o2 and o3 might be different because each time, k-means clustering is performed. ht1 = Heatmap(small_mat, row_km = 2) o1 = row_order(ht1) o2 = row_order(ht1) ht2 = draw(ht1) o3 = row_order(ht2) o4 = row_order(ht2) draw() function returns the heatmap (or more precisely, the heatmap list) which has been reordered, and applying row_order() just extracts the row order from the object, which ensures the row order is exactly the same as the one shown in the heatmap. In above code, o3 is always identical to o4. So, the preferable way to get row/column orders is as follows. # code only for demonstration ht = Heatmap(small_mat) ht = draw(ht) row_order(ht) column_order(ht) If rows/columns are split, row order or column order will be a list. ht = Heatmap(small_mat, row_km = 2, column_km = 3) ht = draw(ht) row_order(ht) ## $`1` ## [1] 9 6 7 8 3 4 ## ## $`2` ## [1] 2 5 1 column_order(ht) ## $`1` ## [1] 5 9 ## ## $`2` ## [1] 8 1 3 4 ## ## $`3` ## [1] 2 7 6 Similarly, the row_dend()/column_dend() functions return the dendrograms. It returns a single dendrogram or a list of dendrograms depending on whether the heatmap is split. ht = Heatmap(small_mat, row_km = 2) ht = draw(ht) row_dend(ht) ## $`1` ## &#39;dendrogram&#39; with 2 branches and 6 members total, at height 3.109169 ## ## $`2` ## &#39;dendrogram&#39; with 2 branches and 3 members total, at height 2.718561 column_dend(ht) ## &#39;dendrogram&#39; with 2 branches and 9 members total, at height 5.191887 row_order(), column_order(), row_dend() and column_dend() also work for a list of heatmaps, it will be expalined in Section ??. 2.13 Subset a heatmap Since heatmap is a representation of a matrix, there is also subset method for the Heatmap class. ht = Heatmap(mat, name = &quot;mat&quot;) dim(ht) ## [1] 18 24 ht[1:10, 1:10] The annotations are subsetted accordingly as well. ht = Heatmap(mat, name = &quot;mat&quot;, row_km = 2, column_km = 3, col = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)), top_annotation = HeatmapAnnotation(foo1 = 1:24, bar1 = anno_points(runif(24))), right_annotation = rowAnnotation(foo2 = 18:1, bar2 = anno_barplot(runif(18))) ) ht[1:9*2 - 1, 1:12*2] # odd rows, even columns The heatmap components are subsetted if they present as vector-like. Some configurations in the heatmap keep the same when subsetting, e.g. if row_km is set in the original heatmap, the configuration of k-means is kept and it is performed in the sub-heatmap. So in following example, k-means clustering is only performed when making heatmap for ht2. ht = Heatmap(mat, name = &quot;mat&quot;, row_km = 2) ht2 = ht[1:10, 1:10] ht2 The implementation of subsetting heatmaps is very experimental. If you have problems or comments, please let me know. "],
["heatmap-annotations.html", "Chapter 3 Heatmap Annotations 3.1 Simple annotation 3.2 Simple annotation as an annotation function 3.3 Empty annotation 3.4 Image annotation 3.5 Points annotation 3.6 Lines annotation 3.7 Barplot annotation 3.8 Boxplot annotation 3.9 histogram annotation 3.10 Density annotation 3.11 Joyplot annotation 3.12 Horizon chart annotation 3.13 Text annotation 3.14 Mark annotation 3.15 Multiple annotations 3.16 Summary annotation 3.17 Utility functions 3.18 Implement new annotation function", " Chapter 3 Heatmap Annotations Heatmap annotations are important components of a heatmap that it shows additional information that associates with rows or columns in the heatmap. ComplexHeatmap package provides very flexible supports for setting annotations or defining new annotation graphics. The annotations can be put on the four sides of the heatmap, by top_annotation, bottom_annotation, left_annotation and right_annotation arguments. The value for the four arguments should be in the HeatmapAnnotation class and should be constructed by HeatmapAnnotation(), or by rowAnnotation() if it is row annotation. (rowAnnotation() is just a helper function which is identical to HeatmapAnnotation(..., which = &quot;row&quot;)) A simple usage of annotations is as follows. set.seed(123) mat = matrix(rnorm(100), 10) column_ha = HeatmapAnnotation(foo1 = runif(10), bar1 = anno_barplot(runif(10))) row_ha = rowAnnotation(foo2 = runif(10), bar2 = anno_barplot(runif(10))) Heatmap(mat, name = &quot;mat&quot;, top_annotation = column_ha, right_annotation = row_ha) Or assign as bottom annotation and left annotation. Heatmap(mat, name = &quot;mat&quot;, bottom_annotation = column_ha, left_annotation = row_ha) In above examples, for column_ha and row_ha, both have two annotations where foo1 and foo2 are numeric vectors and bar1 and bar2 are barplots. The vector-like annotation is called “simple annotation” here and the barplot annotation is called “complex annotation”. You can already see the annotations must be defined as name-value pairs (e.g. foo = ...). Heatmap annotations can also be independent of the heatmaps. They can be concatenated to the heatmap list by + if it is horizontal or %v% if it is vertical. Next chapter will discuss how to concatenate heatmaps/annotations. # code only for demonstration Heatmap(...) + rowAnnotation() + ... Heatmap(...) %v% HeatmapAnnotation(...) + ... HeatmapAnnotation() returns a HeatmapAnnotation class object. The object is usually composed of several annotations. If following sections of this chapter, we first introduce settings for individal annotation, and later we show how to put them toghether. You can see the information of the column_ha and row_ha objects: column_ha ## A HeatmapAnnotation object with 2 annotations ## name: heatmap_annotation_0 ## position: column ## items: 10 ## width: 1npc ## height: 15mm ## this object is  subsetable ## 5.92327473958333mm extension on the left ## 9.47286783854167mm extension on the right ## ## name annotation_type color_mapping height ## foo1 continuous vector random 5mm ## bar1 anno_barplot() 10mm row_ha ## A HeatmapAnnotation object with 2 annotations ## name: heatmap_annotation_1 ## position: row ## items: 10 ## width: 15mm ## height: 1npc ## this object is  subsetable ## 9.95358072916666mm extension on the bottom ## ## name annotation_type color_mapping width ## foo2 continuous vector random 5mm ## bar2 anno_barplot() 10mm In following examples in this chapter, we will only show the grapgics for the annotations with no heatmap, unless it is necessary. If you want to try it with a heatmap, you just assign the HeatmapAnnotation object which we always name as ha to top_annotation, bottom_annotation, left_annotation or right_annotation arguments. Settings are basically the same for column annotations and row annotations. If there is nothing specicial, we only show the column annotation as examples. If you want to try row annotation, just add which = &quot;row&quot; to HeatmapAnnotation() or directly change to rowAnnotation() function. 3.1 Simple annotation A so-called “simple annotation” is the most used style of annotations which is heatmap-like or grid-like graphics where colors are used to map to the anntation values. To generate a simple annotation, you just simply put the annotation vector in HeatmapAnnotation() with a specific name. ha = HeatmapAnnotation(foo = 1:10) Or a discrete annotation: ha = HeatmapAnnotation(bar = sample(letters[1:3], 10, replace = TRUE)) If colors are not specified, colors are randomly generated. To set the colors for annotation, col needs to be set as a named list. For continuous values, the color mapping should be a color mapping function generated by circlize::colorRamp2(). library(circlize) col_fun = colorRamp2(c(0, 5, 10), c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;)) ha = HeatmapAnnotation(foo = 1:10, col = list(foo = col_fun)) And for discrete annotations, the color should be a named vector where names correspond to the levels in the annotation. ha = HeatmapAnnotation(bar = sample(letters[1:3], 10, replace = TRUE), col = list(bar = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;))) If you specify more than one vectors, there will be multiple annotations (foo and bar in following example). Also you can see how col is set when foo and bar are all put into a single HeatmapAnnotation(). Maybe you can understand now the names in the color list is actually used to map to the annotation names. ha = HeatmapAnnotation( foo = 1:10, bar = sample(letters[1:3], 10, replace = TRUE), col = list(foo = col_fun, bar = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;) ) ) The color for NA value is controlled by na_col argument. ha = HeatmapAnnotation( foo = c(1:4, NA, 6:10), bar = c(NA, sample(letters[1:3], 9, replace = TRUE)), col = list(foo = col_fun, bar = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;) ), na_col = &quot;black&quot; ) gp mainly controls the graphic parameters for the borders of the grids. ha = HeatmapAnnotation( foo = 1:10, bar = sample(letters[1:3], 10, replace = TRUE), col = list(foo = col_fun, bar = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;) ), gp = gpar(col = &quot;black&quot;) ) border ha = HeatmapAnnotation( foo = cbind(1:10, 10:1), bar = sample(letters[1:3], 10, replace = TRUE), col = list(foo = col_fun, bar = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;) ), border = TRUE ) The simple annotation can also be a matrix (numeric or character) that all the columns in the matrix share a same color mapping schema. Note columns in the matrix correspond to the rows in the column annotation. Also the column names of the matrix are used as the annotation names. ha = HeatmapAnnotation(foo = cbind(a = runif(10), b = runif(10))) If the matrix has no column name, the name of the annotation is still used, but drawn in the middle of the annotation. ha = HeatmapAnnotation(foo = cbind(runif(10), runif(10))) As simple annotations can be in different modes (e.g. numeric, or character), they can be combined as a data frame and send to df argument. Imaging in your project, you might already have an annotation table, you can directly set it by df. anno_df = data.frame(foo = 1:10, bar = sample(letters[1:3], 10, replace = TRUE)) ha = HeatmapAnnotation(df = anno_df, col = list(foo = col_fun, bar = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;) ) ) Single annotations and data frame can be mixed. In following example, colors for foo2 is not specified, random colors will be used. ha = HeatmapAnnotation(df = anno_df, foo2 = rnorm(10), col = list(foo = col_fun, bar = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;) ) ) The height of the simple annotation is controlled by anno_simple_size argument. Since all single annotations have same height, the value of anno_simple_size is a single unit value. Note there are arguments like width, height, annotation_width and annotation_height, but they are used to adjust the width/height when there are multiple annotations (which are always mix of simple annotations and complex annotations). ha = HeatmapAnnotation( foo = cbind(a = 1:10, b = 10:1), bar = sample(letters[1:3], 10, replace = TRUE), col = list(foo = col_fun, bar = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;) ), anno_simple_size = unit(1, &quot;cm&quot;) ) 3.2 Simple annotation as an annotation function HeatmapAnnotation() supports “complex annotation” by setting the annotation as a function. The annotation function defines how to draw the graphics at a certain position corresponding to the column or row in the heatmap. There are quite a lot of annotation functions predefined in ComplexHeatmap package. In the end of this chapter, we will introduce how to construct your own annotation function by the AnnotationFunction class. For all the annotation functions in forms of anno_*(), if it is specified in HeatmapAnnotation() or rowAnnotation(), you don’t need to do anything explicitly on anno_*() to tell it should be drawn on rows or columns. anno_*() automatically detects whether it is a row annotation environment or a column annotation environment. The simple annotation shown in previous section is internally constructed by anno_simple() annotation function. However, directly using anno_simple() will not automatically generate legends for the final plot. However, it can provide more flexibility for more annotation graphics (note later chapter we will show, although the annotation functions cannot automatically generate the legends, the legends can be controlled and added to the final plot manually). For an example in previous section: # code only for demonstration ha = HeatmapAnnotation(foo = 1:10) is actually identical to: # code only for demonstration ha = HeatmapAnnotation(foo = anno_simple(1:10)) anno_simple() makes heatmap-like annotations (or the simple annotations). Basically if users only make heatmap-like annotations, they do not need to directly use anno_simple(), but this function allows to add more symbols on the annotation grids. anno_simple() allows to add “points” or single-letter symbols on top of the annotation grids. pch, pt_gp and pt_size control the settings of the points. The value of pch can be a vector with possible NA values. ha = HeatmapAnnotation(foo = anno_simple(1:10, pch = 1, pt_gp = gpar(col = &quot;red&quot;), pt_size = unit(seq(1, 10), &quot;mm&quot;))) Set pch as a vector: ha = HeatmapAnnotation(foo = anno_simple(1:10, pch = 1:10)) Set pch as a vector of letters: ha = HeatmapAnnotation(foo = anno_simple(1:10, pch = sample(letters[1:3], 10, replace = TRUE))) Set pch as a vector with NA values (nothing is drawn for NA pch values): ha = HeatmapAnnotation(foo = anno_simple(1:10, pch = c(1:4, NA, 6:8, NA, 10, 11))) pch also works if the value for anno_simple() is a matrix; The length of pch should be as same as the number of matrix rows or columns or even the length of the matrix (the length of the matrix is the length of all data points in the matrix). Lenght of pch corresponds to matrix columns: ha = HeatmapAnnotation(foo = anno_simple(cbind(1:10, 10:1), pch = 1:2)) Lenght of pch corresponds to matrix rows: ha = HeatmapAnnotation(foo = anno_simple(cbind(1:10, 10:1), pch = 1:10)) pch is a matrix: pch = matrix(1:20, nc = 2) pch[sample(length(pch), 10)] = NA ha = HeatmapAnnotation(foo = anno_simple(cbind(1:10, 10:1), pch = pch)) Till now, you might wonder how to set the legends of the symbols you’ve added to the simple annotations. Now We will show you a simple example and this functionality will be d…. In this example, we assume the simple annotations are kind of p-values and we add * for p-values less than 0.01. set.seed(123) pvalue = 10^-runif(10, min = 0, max = 3) is_sig = pvalue &lt; 0.01 pch = rep(&quot;*&quot;, 10) pch[!is_sig] = NA pvalue_col_fun = colorRamp2(c(0, 2, 3), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) # color mapping for -log10(pvalue) ha = HeatmapAnnotation(pvalue = anno_simple(-log10(pvalue), col = pvalue_col_fun, pch = pch), annotation_name_side = &quot;left&quot;) ht = Heatmap(matrix(rnorm(100), 10), name = &quot;mat&quot;, top_annotation = ha) # see how we define the legend for pvalue lgd_pvalue = Legend(title = &quot;p-value&quot;, col = pvalue_col_fun, at = c(0, 1, 2, 3), labels = c(&quot;1&quot;, &quot;0.1&quot;, &quot;0.01&quot;, &quot;0.001&quot;)) lgd_sig = Legend(pch = &quot;*&quot;, type = &quot;points&quot;, labels = &quot;&lt; 0.01&quot;) draw(ht, annotation_legend_list = list(lgd_pvalue, lgd_sig)) The height of the simple annotation can be controled by height argument or anno_simple_size (or width if it is a row annotation) inside anno_simple(). anno_simple_size controls the size for single-row annotation and height/width controls the total height/width of all simple annotations. If height/width is set, anno_simple_size is ignored. ha = HeatmapAnnotation(foo = anno_simple(1:10, height = unit(2, &quot;cm&quot;))) ha = HeatmapAnnotation(foo = anno_simple(cbind(1:10, 10:1), anno_simple_size = unit(2, &quot;cm&quot;))) For all the annotation functions we introduce later, the height or the width for individual annotations should all be set inside the anno_*() functions: # code for demonstration anno_*(width = ...) anno_*(height = ...) Again, the width, height, annotation_width and annotation_height arguments in HeatmapAnnotation() are used to adjust the size of multiple annotations. 3.3 Empty annotation anno_empty() is a place holder where nothing is drawn. Later graphics can be added by decorate_annotation() function. ha = HeatmapAnnotation(foo = anno_empty(border = TRUE)) In Chapter, we will introduce the use of the decoration functions, but here we give a quick example. In gene expression expression analysis, there are senarios that we split the heatmaps into several groups and we want to highlight some key genes in each group. In this case, we simply add the labels on the right side of the heatmap without aligning them to the their corresponding rows. (anno_mark() can align the labels correclty to their corresponding rows, but in the senario we show here, it is not necessray). In following example, basically what we do is in each empty annotation, we add a segment and text. random_text = function(n) { sapply(1:n, function(i) { paste0(sample(letters, sample(4:10, 1)), collapse = &quot;&quot;) }) } text_list = list( text1 = random_text(4), text2 = random_text(5), text3 = random_text(6), text4 = random_text(7) ) ha = rowAnnotation(foo = anno_empty(border = FALSE, width = max_text_width(unlist(text_list)) + unit(4, &quot;mm&quot;))) Heatmap(matrix(rnorm(1000), nrow = 100), name = &quot;mat&quot;, row_km = 4, right_annotation = ha) for(i in 1:4) { decorate_annotation(&quot;foo&quot;, slice = i, { grid.rect(x = 0, width = unit(2, &quot;mm&quot;), gp = gpar(fill = i, col = NA), just = &quot;left&quot;) grid.text(paste(text_list[[i]], collapse = &quot;\\n&quot;), x = unit(4, &quot;mm&quot;), just = &quot;left&quot;) }) } A second use of the empty annotation is to add complex annotation graphics where the empty annotation pretends to be a virtual plotting regions. You can construct an annotation function by AnnotationFunction class for complex annotation graphics, which allows subsetting and splitting, but still, it can be a secondary choice to directly draw inside the empty annotation, which is easier and faster for implementing rather graphics (but less flexible and does not allow splitting). In following we show how to add a “complex version” of points annotation. The only thing that needs to be aware of is the location on x-axes (y-axes if it is a row annotation) should correspond to the column index after column reordering. ha = HeatmapAnnotation(foo = anno_empty(border = TRUE, height = unit(3, &quot;cm&quot;))) ht = Heatmap(matrix(rnorm(100), nrow = 10), name = &quot;mat&quot;, top_annotation = ha) ht = draw(ht) co = column_order(ht) value = runif(10) decorate_annotation(&quot;foo&quot;, { x = 1:10 value = value[co] pushViewport(viewport(xscale = c(0.5, 10.5), yscale = c(0, 1))) grid.lines(c(0.5, 10.5), c(0.5, 0.5), gp = gpar(lty = 2), default.units = &quot;native&quot;) grid.points(x, value, pch = 16, size = unit(2, &quot;mm&quot;), gp = gpar(col = ifelse(value &gt; 0.5, &quot;red&quot;, &quot;blue&quot;)), default.units = &quot;native&quot;) grid.yaxis(at = c(0, 0.5, 1)) popViewport() }) 3.4 Image annotation Images can be added as annotations. anno_image() supports image formats in png, svg, pdf, eps, jpeg/jpg, tiff. png, jpeg/jpg and tiff images are imported by png::readPNG(), jpeg::readJPEG() and tiff::readTIFF(), and drawn by grid::grid.raster(). svg images are firstly reformatted by rsvg::rsvg_svg() and then imported by grImport2::readPicture() and drawn by grImport2::grid.picture(). pdf and eps images are imported by grImport::PostScriptTrace() and grImport::readPicture(), later drawn by grImport::grid.picture(). The free icons for following examples are from https://github.com/Keyamoon/IcoMoon-Free. A vector of image pathes are set as the first argument of anno_image(). image_png = sample(dir(&quot;~/Downloads/IcoMoon-Free-master/PNG/64px&quot;, full.names = TRUE), 10) image_svg = sample(dir(&quot;~/Downloads/IcoMoon-Free-master/SVG/&quot;, full.names = TRUE), 10) image_eps = sample(dir(&quot;~/Downloads/IcoMoon-Free-master/EPS/&quot;, full.names = TRUE), 10) image_pdf = sample(dir(&quot;~/Downloads/IcoMoon-Free-master/PDF/&quot;, full.names = TRUE), 10) # we only draw the image annotation for PNG images, while the others are the same ha = HeatmapAnnotation(foo = anno_image(image_png)) Different image formats can be mixed in the input vector. # code is only for demonstration ha = HeatmapAnnotation(foo = anno_image(c(image_png[1:3], image_svg[1:3], image_eps[1:3], image_pdf[1:3]))) Border and background colors can be set by gp. ha = HeatmapAnnotation(foo = anno_image(image_png, gp = gpar(fill = 1:10, col = &quot;black&quot;))) border controls the border of the whole annotation. # code only for deonstration ha = HeatmapAnnotation(foo = anno_image(image_png, border = &quot;red&quot;)) Padding or space around the images is set by space. ha = HeatmapAnnotation(foo = anno_image(image_png, space = unit(3, &quot;mm&quot;))) If only some of the images need to be drawn, the other elements in the image vector can be set to '' or NA. image_png[1:2] = &quot;&quot; ha = HeatmapAnnotation(foo = anno_image(image_png)) The default height for column image annotation is 1cm. 3.5 Points annotation Points annotation shows distribution of a list of data points. The data points object x can be a single vector or a matrix. If it is a matrix, the graphic settings such as pch, size and gp can correpspond to matrix columns. ha = HeatmapAnnotation(foo = anno_points(runif(10))) ha = HeatmapAnnotation(foo = anno_points(matrix(runif(20), nc = 2), pch = 1:2, gp = gpar(col = 2:3))) ylim controls the range on “y-axis” or the “data axis” (if it is a row annotation, the data axis is horizontal), extend controls the extended space on the data axis direction. axis controls whether to show the axis and axis_param controls the settings for axis. The default settings for axis are: default_axis_param(&quot;column&quot;) ## $at ## NULL ## ## $labels ## NULL ## ## $labels_rot ## [1] 0 ## ## $gp ## $fontsize ## [1] 8 ## ## ## $side ## [1] &quot;left&quot; ## ## $facing ## [1] &quot;outside&quot; And you can overwrite some of them: ha = HeatmapAnnotation(foo = anno_points(runif(10), axis_param = list( side = &quot;right&quot;, at = c(0, 0.5, 1), labels = c(&quot;zero&quot;, &quot;half&quot;, &quot;one&quot;) )) ) The configuration of axis is same for other annotation functions which have axes. The default height of the column points annotation is 1cm. 3.6 Lines annotation anno_lines() connects the data points by a list of segments. Similar as anno_points(), the data variable can be a numeric vector: ha = HeatmapAnnotation(foo = anno_lines(runif(10))) Or a matrix: ha = HeatmapAnnotation(foo = anno_lines(cbind(c(1:5, 1:5), c(5:1, 5:1)), gp = gpar(col = 2:3), add_points = TRUE, pt_gp = gpar(col = 5:6), pch = c(1, 16))) Smoothed lines (by loess()) can be added instead of the original lines by setting smooth = TRUE, but it should be used with caution because the order of columns in the heatmap is used as “x-value” for the fitting and the order will change after the clustering of the heatmap. Smoothing also works in the input data variable is a matrix that the smoothing is performed for each column separately. ha = HeatmapAnnotation(foo = anno_lines(runif(10), smooth = TRUE, add_points = TRUE)) The default height for column lines annotation is 1cm. 3.7 Barplot annotation The data points can be represented as barplots. Some of the arguments such as ylim, axis, axis_param are same as anno_points() that users can refer to the documentation of anno_barplot(). ha = HeatmapAnnotation(foo = anno_barplot(1:10)) The width of bars is controlled by bar_width. It is a relative value to the width of the cell in the heatmap. ha = HeatmapAnnotation(foo = anno_barplot(1:10, bar_width = 1)) Graphic parameters are controlled by gp. ha = HeatmapAnnotation(foo = anno_barplot(1:10, gp = gpar(fill = 1:10))) You choose the baseline of bars by baseline. ha = HeatmapAnnotation(foo = anno_barplot(seq(-5, 5), baseline = &quot;min&quot;)) If the input value is a matrix, it will be represented as stacked barplots. ha = HeatmapAnnotation(foo = anno_barplot(matrix(nc = 2, c(1:10, 10:1)))) And length of parameters in gp can be the number of the columns in the matrix: ha = HeatmapAnnotation(foo = anno_barplot(cbind(1:10, 10:1), gp = gpar(fill = 2:3, col = 2:3))) Following example shows a barplot annotation which visualizes a proportion matrix (for which row sums are 1). m = matrix(runif(4*10), nc = 4) m = t(apply(m, 1, function(x) x/sum(x))) ha = HeatmapAnnotation(foo = anno_barplot(m, gp = gpar(fill = 2:5), bar_width = 1, height = unit(6, &quot;cm&quot;))) The default height for column barplot annotation is 1cm. 3.8 Boxplot annotation Boxplot annotation as well as the annotation functions which are introduced later are more suitable for small matrice. You don’t want to put boxplots as column annotation for a matrix with 100 columns. For anno_boxplot(), the input data variable should be a matrix or a list. If x is a matrix and if it is a column annotation, statistics for boxplots are calculated by columns, and if it is a row annotation, the calculation is done by rows. set.seed(12345) m = matrix(rnorm(100), 10) ha = HeatmapAnnotation(foo = anno_boxplot(m, height = unit(4, &quot;cm&quot;))) Graphic parameters are controlled by gp. ha = HeatmapAnnotation(foo = anno_boxplot(m, height = unit(4, &quot;cm&quot;), gp = gpar(fill = 1:10))) Width of the boxes are controlled by box_width. outline controls whether to show outlier points. ha = HeatmapAnnotation(foo = anno_boxplot(m, height = unit(4, &quot;cm&quot;), box_width = 0.9, outline = FALSE)) The default height of column boxplot annotation is 2cm. 3.9 histogram annotation Annotations as histograms are more suitable to put as row annotations. The histogram annotation shows the distribution of each row by histograms. The setting for the data variable is the same as anno_boxplot() which can be a matrix or a list. m = matrix(rnorm(1000), nc = 100) ha = rowAnnotation(foo = anno_histogram(m)) # apply `m` on rows Number of breaks for histograms is controlled by n_breaks. ha = rowAnnotation(foo = anno_histogram(m, n_breaks = 20)) Colors are controlled by gp. ha = rowAnnotation(foo = anno_histogram(m, gp = gpar(fill = 1:10))) The default for column histogram annotation is 4cm. 3.10 Density annotation Similar as histogram annotations, anno_density() shows the distribution as a fitted curve. ha = rowAnnotation(foo = anno_density(m)) The height of the density lines can be controlled to make the distribution look like a “joyplot”. ha = rowAnnotation(foo = anno_density(m, joyplot_scale = 2, gp = gpar(fill = &quot;#CCCCCC80&quot;))) Or visualize the distribution as violin plot. ha = rowAnnotation(foo = anno_density(m, type = &quot;violin&quot;, gp = gpar(fill = 1:10))) When there are too many rows, the space for normal density peaks might be too small. In this case, we can visualize the distribution by heatmaps. ha = rowAnnotation(foo = anno_density(m, type = &quot;heatmap&quot;, width = unit(6, &quot;cm&quot;))) THe color schema for heatmap distribution is controlled by heatmap_colors. ha = rowAnnotation(foo = anno_density(m, type = &quot;heatmap&quot;, width = unit(6, &quot;cm&quot;), heatmap_colors = c(&quot;white&quot;, &quot;orange&quot;))) In ComplexHeatmap package, there is a densityHeatmap() function which visualizes distribution as a heatmap (not an annotation). 3.11 Joyplot annotation anno_joyplot() is specifical for so-called joyplot (http://blog.revolutionanalytics.com/2017/07/joyplots.html). m = matrix(rnorm(1000), nc = 10) lt = apply(m, 2, function(x) data.frame(density(x)[c(&quot;x&quot;, &quot;y&quot;)])) ha = rowAnnotation(foo = anno_joyplot(lt, width = unit(4, &quot;cm&quot;), gp = gpar(fill = 1:10), transparency = 0.75)) Or only show the lines. m = matrix(rnorm(5000), nc = 50) lt = apply(m, 2, function(x) data.frame(density(x)[c(&quot;x&quot;, &quot;y&quot;)])) ha = rowAnnotation(foo = anno_joyplot(lt, width = unit(4, &quot;cm&quot;), gp = gpar(fill = NA), scale = 4)) 3.12 Horizon chart annotation Horizon chart as annotation can only be added as row annotation. The value for anno_horizon() should be a list or a matrix where matrix columns correspond to rows in the annotation. The default style of horizon chart annotation is: lt = lapply(1:20, function(x) cumprod(1 + runif(1000, -x/100, x/100)) - 1) ha = rowAnnotation(foo = anno_horizon(lt)) Colors for positive values and negative values are controlled by pos_fill and neg_fill in gar(). ha = rowAnnotation(foo = anno_horizon(lt, gp = gpar(pos_fill = &quot;orange&quot;, neg_fill = &quot;darkgreen&quot;))) pos_fill and neg_fill can be assigned as a vector. ha = rowAnnotation(foo = anno_horizon(lt, gp = gpar(pos_fill = rep(c(&quot;orange&quot;, &quot;red&quot;), each = 10), neg_fill = rep(c(&quot;darkgreen&quot;, &quot;blue&quot;), each = 10)))) Whether the peaks for negative values start from the bottom or the top? ha = rowAnnotation(foo = anno_horizon(lt, negative_from_top = TRUE)) The space between every two neighbouring charts. ha = rowAnnotation(foo = anno_horizon(lt, gap = unit(1, &quot;mm&quot;))) 3.13 Text annotation Text can be used as annotations by anno_text(). Graphic parameters are controlled by gp. ha = rowAnnotation(foo = anno_text(month.name, gp = gpar(fontsize = 1:12+4))) Locationsn are controlled by location and just. Rotation is controlled by rot. ha = rowAnnotation(foo = anno_text(month.name, location = 1, rot = 45, just = &quot;right&quot;, gp = gpar(fontsize = 1:12+4))) 3.14 Mark annotation Sometimes there are many rows or columns in the heatmap and we want to mark some of them. anno_mark() is used to mark subset of rows or columns and connect labels with lines. m = matrix(rnorm(1000), nrow = 100) ha = rowAnnotation(foo = anno_mark(at = c(1:4, 20, 60, 97:100), labels = month.name[1:10])) Heatmap(m, cluster_rows = FALSE, right_annotation = ha) 3.15 Multiple annotations As mentioned before, to put multiple annotations in HeatmapAnnotation(), they just need to be specified as name-value pairs. In HeatmapAnnotation(), there are some arguments which controls multiple annotations. For these arguments, they are specified as a vector which has same length as number of the annotations, or a named vector with subset of the annotations. The simple annotations which are specified as vectors, matrices and data frames will automatically have legends on the heatmap. show_legend controls whether draw the legend for them. Note here if show_legend is a vector, the length of show_legend should be the same as the simple annotations while not the number of all annotations. gp controls graphic parameters (except fill) for the simple annotatios, such as the border of annotation grids. border controls the border of every single annotations. show_annotation_name controls whether show annotation names. As mentioned, the value can be a single value, a vector or a named vector. annotation_name_gp, annotation_name_offset, annotation_name_side and annotation_name_rot controls the style and positions of the annotation names. gap controls the space between every two neighbouring annotations. The value can be a single unit or a vector of units. ha = HeatmapAnnotation(foo = 1:10, bar = cbind(1:10, 10:1), pt = anno_points(1:10), gap = unit(2, &quot;mm&quot;)) ha = HeatmapAnnotation(foo = 1:10, bar = cbind(1:10, 10:1), pt = anno_points(1:10), gap = unit(c(2, 10), &quot;mm&quot;)) height, width, annotation_height and annotation_width control the height or width of the heatmap annotations. Normally you don’t need to set it because all the single annotations have fixed height/width and the final height/width for the whole heatmap annotation is the sum of them plus the sum of gaps. … 3.16 Summary annotation 3.17 Utility functions 3.18 Implement new annotation function A normal R function defines how to draw the annotation graphics. As expected, the main part of the AnnotationFunction class is this function. The function defines how to draw at specific positions which correspond to rows or columns in the heatmap. The function should have three arguments: index, k and n (the names of the arguments can be arbitory) where k and n are optional. index corresponds to the indices of rows or columns of the heatmap. The value of index is not necessarily to be the whole row indices or column indices. It can also be a subset of the indices if the annotation is split into slices according to the split of the heatmap. The value in index is always sorted according to the reordering of heatmap rows or columns (e.g. by clustering). So, index actually contains a list of row or column indices for the current slice after row or column reordering. This type of design makes sure the annotation graphics are drawn at the correct positions and can be correctly corresponded to the heatmap rows or columns. As mentioned, annotation can be split into slices. k corresponds to the current slice and n corresponds to the total number of slices. The information of k and n sometimes can be useful, for example, we want to add axis in the annotation, and if it is a column annotation and axis is drawn on the very right of the annotation area, the axis is only drawn when k == n. Since the function only allows index, k and n, the function sometimes uses several external variables which can not be defined inside the function, e.g. the data points for the annotation. These variables should be imported into the AnnotationFunction class so that the function can correctly find these variables. One important feature for AnnotationFunction class is it can be subsetable. To allow subsetting of the object, users need to define the rule for the imported variables if there is any. The rules are simple function which accpets the variable and indices, and returns the subset of the variable. The subset rule functions implemented in this package are subset_gp, subset_matrix_by_row and subset_vector. These three functions are enough for most of the cases. In following, we defined three AnnotationFunction objects: It needs external variable and support subsetting x = 1:10 anno1 = AnnotationFunction( fun = function(index) { n = length(index) pushViewport(viewport()) grid.points(1:n, x[index]) popViewport() }, var_imported = list(x = x), n = 10, subset_rule = list(x = subset_vector), subsetable = TRUE ) The data variable is defined inside the function and no need to import other variables. anno2 = AnnotationFunction( fun = function(index) { x = 1:10 n = length(index) pushViewport(viewport()) grid.points(1:n, x[index]) popViewport() }, n = 10, subsetable = TRUE ) The most compact way to only specify the function to the constructor. anno3 = AnnotationFunction( fun = function(index) { x = 1:10 n = length(index) pushViewport(viewport()) grid.points(1:n, x[index]) popViewport() } ) Finally, you need to push a viewport for graphics and finally pop the viewport. "],
["a-list-of-heatmaps.html", "Chapter 4 A List of Heatmaps 4.1 Titles 4.2 Size of heatmaps 4.3 Gap between heatmaps 4.4 Auto adjustment to the main heatmap 4.5 control row … in draw() function 4.6 Annotation as components are adjusted 4.7 concatenate with annotations 4.8 Only annotations 4.9 vertical align 4.10 Retrieve orders and dendrograms 4.11 Change graphic parameters simultaneously 4.12 Session info", " Chapter 4 A List of Heatmaps The main feature of ComplexHeatmap package is it supports to concatenate a list of heatmaps/annotations horizontally or vertically so that it makes it possible to visualize the associations from various sources of information. In this chapter, we mainly introduce the horizontal concatenation because this is the major case we will use in the analysis. In the end we show some examples of vertical concatenation. The concept behind basically is similar. For the horizontal concatenation, the number of rows for all heatmaps/annotations should be the same. In following we first introduce the concatenation of heatmaps and later we will show how to concatenate heatmaps with annotations. In following example, there are three matrices where the third heatmap is a vector and it will be transformed as a one-column matrix. The one-column heatmap is sometimes useful when you concatenate a list of heatmaps that it can show e.g. annotations for each row or some scores of each row. e.g. if rows are genes, the the whether genes are protein coding gene can be represented …, or p-values or foldchange from differnetial… To concatenate heatmaps, simply use + operator. set.seed(123) mat1 = matrix(rnorm(80, 2), 8, 10) mat1 = rbind(mat1, matrix(rnorm(40, -2), 4, 10)) rownames(mat1) = paste0(&quot;R&quot;, 1:12) colnames(mat1) = paste0(&quot;C&quot;, 1:10) mat2 = matrix(runif(60, max = 3, min = 1), 6, 10) mat2 = rbind(mat2, matrix(runif(60, max = 2, min = 0), 6, 10)) rownames(mat2) = paste0(&quot;R&quot;, 1:12) colnames(mat2) = paste0(&quot;C&quot;, 1:10) le = sample(letters[1:3], 12, replace = TRUE) names(le) = paste0(&quot;R&quot;, 1:12) ind = sample(12, 12) mat1 = mat1[ind, ] mat2 = mat2[ind, ] le = le[ind] ht1 = Heatmap(mat1, name = &quot;rnorm&quot;) ht2 = Heatmap(mat2, name = &quot;runif&quot;) ht3 = Heatmap(le, name = &quot;letters&quot;) ht1 + ht2 + ht3 Under default mode, dendrograms from the second heatmap will be removed and row orders will be same as the first one. also row names which are put on the right side of the heatmap for hte first two heatmaps are removed as well. The returned value of addition of two heatmaps is a HeatmapList object. Directly calling ht_list object will call draw() method with default settings. With explicitly calling draw() method, you can have more controls e.g. on the legend and titles. ht_list = ht1 + ht2 + ht3 class(ht_list) ## [1] &quot;HeatmapList&quot; ## attr(,&quot;package&quot;) ## [1] &quot;ComplexHeatmap&quot; You can append any number of heatmaps to the heatmap list. Also you can append a heatmap list to a heatmap list. ht1 + ht_list ht_list + ht1 ht_list + ht_list NULL can be added to the heatmap list. It would be convinient when users want to construct a heatmap list through a for loop. ht_list = NULL ## Heatmap(...) + NULL gives you a HeatmapList object for(s in sth) { ht_list = ht_list + Heatmap(...) } 4.1 Titles A heatmap list also has titles which are independent to the heatmap titles. col_rnorm = colorRamp2(c(-3, 0, 3), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)) col_runif = colorRamp2(c(0, 3), c(&quot;white&quot;, &quot;orange&quot;)) col_letters = c(&quot;a&quot; = &quot;pink&quot;, &quot;b&quot; = &quot;purple&quot;, &quot;c&quot; = &quot;blue&quot;) ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, row_title = &quot;Heatmap 1&quot;, column_title = &quot;Heatmap 1&quot;) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif, row_title = &quot;Heatmap 2&quot;, column_title = &quot;Heatmap 2&quot;) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) ht_list = ht1 + ht2 + ht3 draw(ht_list, row_title = &quot;Three heatmaps, row title&quot;, row_title_gp = gpar(col = &quot;red&quot;), column_title = &quot;Three heatmaps, column title&quot;, column_title_gp = gpar(fontsize = 16)) 4.2 Size of heatmaps The width for some (not all) heatmaps can be set to a fixed width. ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif, width = unit(4, &quot;cm&quot;)) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters, width = unit(5, &quot;mm&quot;)) ht1 + ht2 + ht3 or the width can be set as relative values. Please not in this case, width for all heatmaps should be set (relative width and fixed width can be mixed). ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, width = unit(4, &quot;cm&quot;)) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif, width = unit(6, &quot;cm&quot;)) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters, width = unit(1, &quot;cm&quot;)) ht1 + ht2 + ht3 ## Since all heatmaps/annotations have absolute units, the total width of the plot is 151mm ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, show_row_names = FALSE, width = 6) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif, show_row_names = FALSE, width = 4) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters, width = 1) ht1 + ht2 + ht3 4.3 Gap between heatmaps ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) draw(ht_list, ht_gap = unit(1, &quot;cm&quot;)) draw(ht_list, ht_gap = unit(c(3, 10), &quot;mm&quot;)) 4.4 Auto adjustment to the main heatmap There are some automatic adjustment if more than one heatmaps are plotted. There should be a main heatmap which by default is the first one. Some settings for the remaining heatmaps will be modified to the settings in the main heatmap. The adjustment are: row clusters are removed. row titles are removed. if the main heatmap is split by rows, all remaining heatmaps will also be split by same levels as the main one. The main heatmap can be specified by main_heatmap argument. The value can be a numeric index or the name of the heatmap (of course, you need to set the heatmap name when you create the Heatmap object). ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, km = 2) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) ht2 + ht1 + ht3 here although ht1 is the second heatmap, we specify ht1 to be the main heatmap by explicitely setting main_heatmap argument ht_list = ht2 + ht1 + ht3 draw(ht_list, main_heatmap = &quot;rnorm&quot;) ht_list = ht2 + ht1 + ht3 draw(ht_list, main_heatmap = &quot;rnorm&quot;, row_dend_side = &quot;right&quot;, row_sub_title_side = &quot;left&quot;) If there is no row clustering in the main heatmap, all other heatmaps have no row clustering neither. ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, cluster_rows = FALSE) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) ht1 + ht2 + ht3 4.5 control row … in draw() function Since the main heamtap controls the row order of all heatmaps, the parameters which co… cluster_rows clustering_distance_rows clustering_method_rows row_dend_width show_row_dend row_dend_reorder row_dend_gp row_order And for splitting rows row_gap row_km row_split ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, row_km = 2) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) ht_list = ht1 + ht2 + ht3 draw(ht_list, row_km = 1, row_split = le, cluster_rows = FALSE) 4.6 Annotation as components are adjusted ha1 = HeatmapAnnotation(foo1 = 1:10, annotation_name_side = &quot;left&quot;) ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, top_annotation = ha1) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) ht1 + ht2 + ht3 ha1 = HeatmapAnnotation(foo1 = 1:10, bar1 = anno_points(1:10), annotation_name_side = &quot;left&quot;) ha2 = HeatmapAnnotation(bar2 = anno_barplot(1:10)) ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, top_annotation = ha1) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif, top_annotation = ha2) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) ht_list = ht1 + ht2 + ht3 draw(ht_list, ht_gap = unit(c(6, 2), &quot;mm&quot;)) ha1 = HeatmapAnnotation(foo1 = 1:10, annotation_name_side = &quot;left&quot;) ha2 = HeatmapAnnotation(bar2 = anno_barplot(1:10)) ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, top_annotation = ha1) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif, top_annotation = ha2) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) ht_list = ht1 + ht2 + ht3 draw(ht_list, ht_gap = unit(c(6, 2), &quot;mm&quot;)) ha1 = HeatmapAnnotation(foo1 = 1:10, bar1 = anno_points(1:10), annotation_name_side = &quot;left&quot;) ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, bottom_annotation = ha1) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif) ht3 = Heatmap(le, name = &quot;letters&quot;, col = col_letters) ht_list = ht1 + ht2 + ht3 draw(ht_list) 4.7 concatenate with annotations For horizontal concatenation with the annotaions. ha1 = rowAnnotation(foo = 1:12, bar = anno_barplot(1:12, width = unit(4, &quot;cm&quot;))) ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, row_km = 2) ht1 + ha1 Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, row_km = 2) + rowAnnotation(foo = 1:12) + rowAnnotation(bar = anno_barplot(1:12, width = unit(4, &quot;cm&quot;))) Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm, row_km = 2) + rowAnnotation(foo = 1:12) + rowAnnotation(bar = anno_barplot(1:12, width = unit(4, &quot;cm&quot;))) + Heatmap(mat2, name = &quot;runif&quot;, col = col_runif) 4.8 Only annotations rowAnnotation(foo = 1:12) + rowAnnotation(bar = anno_barplot(1:12, width = unit(4, &quot;cm&quot;))) ## Since all heatmaps/annotations have absolute units, the total width of the plot is 62mm rowAnnotation(bar = anno_barplot(1:12, width = unit(4, &quot;cm&quot;))) + NULL ## Since all heatmaps/annotations have absolute units, the total width of the plot is 44mm 4.9 vertical align mat1t = t(mat1) mat2t = t(mat2) ht1 = Heatmap(mat1t, name = &quot;rnorm&quot;, col = col_rnorm) ht2 = Heatmap(mat2t, name = &quot;runif&quot;, col = col_runif) ht3 = Heatmap(rbind(letters = le), name = &quot;letters&quot;, col = col_letters) ht_list = ht1 %v% ht2 %v% ht3 draw(ht_list) draw(ht_list, column_km = 2) ht1 = Heatmap(mat1t, name = &quot;rnorm&quot;, col = col_rnorm) ht2 = Heatmap(mat2t, name = &quot;runif&quot;, col = col_runif) ht3 = Heatmap(rbind(letters = le), name = &quot;letters&quot;, col = col_letters) ha = HeatmapAnnotation(foo = anno_barplot(1:12, height = unit(2, &quot;cm&quot;))) ht_list = ht1 %v% ha %v% ht2 %v% ht3 draw(ht_list, column_km = 2) ht1 = Heatmap(mat1t, name = &quot;rnorm&quot;, col = col_rnorm, row_km = 2) ht2 = Heatmap(mat2t, name = &quot;runif&quot;, col = col_runif, row_km = 2) ht3 = Heatmap(rbind(letters = le), name = &quot;letters&quot;, col = col_letters) ha = HeatmapAnnotation(foo = anno_barplot(1:12, height = unit(2, &quot;cm&quot;))) ht_list = ht1 %v% ha %v% ht2 %v% ht3 draw(ht_list, column_km = 2) 4.10 Retrieve orders and dendrograms row_order, column_order, row_dend and column_dend can be used to retrieve corresponding information from the heatmaps. The usage is straightforward by following example: ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif) ht_list = ht1 + ht2 ht_list = draw(ht_list) row_order(ht_list) ## [1] 8 6 10 11 5 7 9 2 12 4 1 3 column_order(ht_list) ## $rnorm ## [1] 2 7 5 6 10 1 9 8 4 3 ## ## $runif ## [1] 1 3 8 7 6 9 4 10 2 5 ht1 = Heatmap(mat1, name = &quot;rnorm&quot;, col = col_rnorm) ht2 = Heatmap(mat2, name = &quot;runif&quot;, col = col_runif, column_km = 2) ht_list = ht1 + ht2 ht_list = draw(ht_list, row_km = 2) row_order(ht_list) ## $`1` ## [1] 12 4 1 3 ## ## $`2` ## [1] 8 6 10 11 5 7 9 2 column_order(ht_list) ## $rnorm ## $rnorm[[1]] ## [1] 2 7 5 6 10 1 9 8 4 3 ## ## ## $runif ## $runif$`1` ## [1] 1 3 8 7 6 9 ## ## $runif$`2` ## [1] 4 10 2 5 Same logic for vertical … which we will not show here 4.11 Change graphic parameters simultaneously ht_opt() can set graphic parameters for dimension names and titles as global settings. ht_opt ## Option Value ## heatmap_row_names_gp NULL ## heatmap_column_names_gp NULL ## heatmap_row_title_gp NULL ## heatmap_column_title_gp NULL ## legend_title_gp NULL ## legend_title_position NULL ## legend_labels_gp NULL ## legend_grid_height NULL ## legend_grid_width NULL ## legend_border NULL ## heatmap_border NULL ## annotation_border NULL ## fast_hclust FALSE ## verbose FALSE ## show_vp FALSE ## anno_simple_size 5mm ## DENDROGRAM_PADDING 0.5mm ## DIMNAME_PADDING 1mm ## TITLE_PADDING 2.5mm ## COLUMN_ANNO_PADDING 1mm ## ROW_ANNO_PADDING 1mm ht_opt(heatmap_column_names_gp = gpar(fontface = &quot;italic&quot;), heatmap_column_title_gp = gpar(fontsize = 10), legend_border = &quot;black&quot;, heatmap_border = TRUE, annotation_border = TRUE ) ht1 = Heatmap(mat1, name = &quot;ht1&quot;, column_title = &quot;Heatmap 1&quot;, top_annotation = HeatmapAnnotation(foo = 1:10)) ht2 = Heatmap(mat2, name = &quot;ht2&quot;, column_title = &quot;Heatmap 2&quot;, top_annotation = HeatmapAnnotation(bar = 1:10)) ht1 + ht2 ht_opt(RESET = TRUE) Following are global settings supported by ht_global_opt(). By this function, you can also control settings for the legends. 4.12 Session info sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS High Sierra 10.13.2 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8 ## ## attached base packages: ## [1] grid methods stats graphics grDevices utils datasets ## [8] base ## ## other attached packages: ## [1] dendsort_0.3.3 dendextend_1.8.0 circlize_0.4.5 ## [4] ComplexHeatmap_1.99.0 ## ## loaded via a namespace (and not attached): ## [1] shape_1.4.4 modeltools_0.2-22 GetoptLong_0.1.7 ## [4] tidyselect_0.2.4 xfun_0.3 kernlab_0.9-27 ## [7] purrr_0.2.5 lattice_0.20-35 colorspace_1.3-2 ## [10] viridisLite_0.3.0 htmltools_0.3.6 stats4_3.4.4 ## [13] yaml_2.2.0 rlang_0.2.2 pillar_1.3.0 ## [16] glue_1.3.0 prabclus_2.2-6 RColorBrewer_1.1-2 ## [19] fpc_2.1-11.1 bindrcpp_0.2.2 plyr_1.8.4 ## [22] bindr_0.1.1 robustbase_0.93-2 stringr_1.3.1 ## [25] munsell_0.5.0 gtable_0.2.0 mvtnorm_1.0-8 ## [28] GlobalOptions_0.1.1 evaluate_0.11 knitr_1.20 ## [31] flexmix_2.3-14 class_7.3-14 DEoptimR_1.0-8 ## [34] trimcluster_0.1-2.1 Rcpp_0.12.18 scales_1.0.0 ## [37] backports_1.1.2 diptest_0.75-7 gridExtra_2.3 ## [40] rjson_0.2.20 ggplot2_3.0.0 digest_0.6.17 ## [43] stringi_1.2.4 bookdown_0.7 dplyr_0.7.6 ## [46] rprojroot_1.3-2 tools_3.4.4 magrittr_1.5 ## [49] lazyeval_0.2.1 tibble_1.4.2 cluster_2.0.7-1 ## [52] crayon_1.3.4 whisker_0.3-2 pkgconfig_2.0.2 ## [55] MASS_7.3-50 viridis_0.5.1 assertthat_0.2.0 ## [58] rmarkdown_1.10 R6_2.2.2 mclust_5.4.1 ## [61] nnet_7.3-12 compiler_3.4.4 "],
["legends.html", "Chapter 5 Legends 5.1 Continuous legend 5.2 Discrete legend 5.3 A list of legends 5.4 Heatmap and annotation legends 5.5 To add customized legend. 5.6 legends setting for the heatmaps", " Chapter 5 Legends The heatmaps and simple annotations automatically generate legends which are put one the right side of the heatmap. By default there is no legend for complex annotations, but they can be constructed and added manually. All legends are constructed by Legend() contructor. In later sections, we first introduce the settings for continuous legends and discrete legends, then we will discuss how to configure the legends associated with the heatmaps and annotations, and how to add new legends to the plot. All the legends (no matter a single legend or a pack of legends) all belong to the Legends class. The class only has one slot grob which is the real grid::grob object or the grid::gTree object that records how to draw the graphics. The wrapping of the Legends class and the methods designed for the class make legends as single compacted objects and can be draw like points with specifying the positions of the legends. 5.1 Continuous legend Since most of heatmaps contain continuous values, we first introduce the settings for continuous legend. Continuous legend needs a color mapping function which should be generated by circlize::colorRamp2(). In the heatmap legends and annotation legends that are automatically generated, the color mapping functions are passed by the col argument from Heatmap() or HeatmapAnnotation() function, while if you construct a separated legend, you need to provide the color mapping function. The break values provides in the color mapping function (e.g. c(0, 0.5, 1)) will not exactly be the same as the break values in the legends). The finally break values presented in the legend are internally adjusted to make the numbers close to 5 or 6. First we show the default style of a vertical continuous legend: library(circlize) col_fun = colorRamp2(c(0, 0.5, 1), c(&quot;blue&quot;, &quot;white&quot;, &quot;red&quot;)) lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;) lgd is a Legends class object. The size of the legend can be obtained by width() and height() function. width(lgd) ## [1] 9.90409342447917mm # the three values are the height of the title, the gap between title and legend, # and the height of the legend. height(lgd) ## [1] 2.52525499131945mm+1.5mm+24mm The legend which is actually a packed graphic objects composed of rectangles, lines, text can be added by draw() function. In ComplexHeatmap pacakge, you don’t need to use draw() directly on legend objects, but it might be useful if you use the legend objects in other places. # code only for demonstration draw(lgd, x = , y = , just = ) If you only want to configure the legends generated by heatmaps or annotations, you don’t need to construct the Legends object by your own, but the parameters introduced later can be used to customize the legends by heatmap_legend_param argument in Heatmap() and annotation_legend_param argument in HeatmapAnnotation(). It is still nice to see how these parameters change the styles of the legend in following examples. In following examples, we only show how to construct the legend object, while not show the code which draws the legends. Only remember you can use draw() function on the Legends object to draw the single legend on the plot. For continuous legend, you can manually adjust the break values in the legend by setting at. Note the height is automatically adjusted. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.25, 0.5, 0.75, 1)) The labels corresponding to the break values are set by labels. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.5, 1), labels = c(&quot;low&quot;, &quot;median&quot;, &quot;high&quot;)) The height of the vertical continous legend is set by legend_height. legend_height can only be set for the veritcal continous legend and the value is the height of the legend body (exluding the legend title). lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, legend_height = unit(6, &quot;cm&quot;)) If it is a vertical legend, grid_width controls the widths of the legend body. grid_width is originally designed for the discrete legends where the each level in the legend is a grid, but here we use the same name for the parameter that controls the width of the legend. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, grid_width = unit(1, &quot;cm&quot;)) The graphic parameters for the labels are controlled by labels_gp. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, labels_gp = gpar(col = &quot;red&quot;, font = 3)) The border of the legend as well as the ticks for the break values are controlled by border. The value of border can be logical or a string of color. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, border = &quot;red&quot;) title_position controls the position of titles. For vertical legends, the value should be one of topleft, topcenter, lefttop-rot and leftcenter-rot. Following two shows the effect of lefttop-rot title and leftcenter-rot title. lgd = Legend(col_fun = col_fun, title = &quot;foooooooo&quot;, title_position = &quot;lefttop-rot&quot;, legend_height = unit(4, &quot;cm&quot;)) lgd = Legend(col_fun = col_fun, title = &quot;foooooooo&quot;, title_position = &quot;leftcenter-rot&quot;, legend_height = unit(4, &quot;cm&quot;)) Settings for horizontal continuous legends are almost the same as vertical legends, except that now legend_width controls the width of the legend, and the title position can only be one of topcenter, topleft, lefttop and leftcenter. The default style for horizontal legend: lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, direction = &quot;horizontal&quot;) Manually set at: lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.25, 0.5, 0.75, 1), direction = &quot;horizontal&quot;) Manually set labels: lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.5, 1), labels = c(&quot;low&quot;, &quot;median&quot;, &quot;high&quot;), direction = &quot;horizontal&quot;) Set legend_width: lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, legend_width = unit(6, &quot;cm&quot;), direction = &quot;horizontal&quot;) Set graphic parameters for labels: lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, labels_gp = gpar(col = &quot;red&quot;, font = 3), direction = &quot;horizontal&quot;) Title can be set as topleft, topcenter or lefttop and leftcenter. lgd = Legend(col_fun = col_fun, title = &quot;foooooooo&quot;, direction = &quot;horizontal&quot;, title_position = &quot;topcenter&quot;) lgd = Legend(col_fun = col_fun, title = &quot;foooooooo&quot;, direction = &quot;horizontal&quot;, title_position = &quot;lefttop&quot;) In examples we showed above, the intervals between every two break values are equal. Actually at can also be set as break values with uneuqal intervals. In this scenario, the ticks on the legend are still at the original places while the corresponding texts are shifted to get rid of overlapping. Then, there is lines linking the ticks and the texts. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.1, 0.15, 0.5, 0.9, 0.95, 1)) If the labels do not need to be adjusted, they are still at the original places and there will be no links. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.3, 1), legend_height = unit(4, &quot;cm&quot;)) It is similar for the horizontal legends: lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.1, 0.15, 0.5, 0.9, 0.95, 1), direction = &quot;horizontal&quot;) Set rotations of labels to 90 degree. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.1, 0.15, 0.5, 0.9, 0.95, 1), direction = &quot;horizontal&quot;, title_position = &quot;lefttop&quot;, labels_rot = 90) When the position of title is set to lefttop, the area below the title will also be taken into account of calculating the adjusted positions of labels. lgd = Legend(col_fun = col_fun, title = &quot;foo&quot;, at = c(0, 0.1, 0.5, 0.75, 1), labels = c(&quot;mininal&quot;, &quot;q10&quot;, &quot;median&quot;, &quot;q75&quot;, &quot;maximal&quot;), direction = &quot;horizontal&quot;, title_position = &quot;lefttop&quot;) 5.2 Discrete legend Discrete legends are used for discrete color mapping. The continuous color mapping can be degenerated as discrete color mapping by only providing the colors corresponding to the break values. You can either specify at or labels, but most probably you specify labels. The colors should be specified by legend_gp. lgd = Legend(at = 1:6, title = &quot;foo&quot;, legend_gp = gpar(fill = 1:6)) lgd = Legend(labels = month.name[1:6], title = &quot;foo&quot;, legend_gp = gpar(fill = 1:6)) The position of title: lgd = Legend(labels = month.name[1:6], title = &quot;foo&quot;, legend_gp = gpar(fill = 1:6), title_position = &quot;lefttop&quot;) lgd = Legend(labels = month.name[1:6], title = &quot;foo&quot;, legend_gp = gpar(fill = 1:6), title_position = &quot;leftcenter-rot&quot;) The size of grids are controlled by grid_width and grid_height. lgd = Legend(at = 1:6, legend_gp = gpar(fill = 1:6), title = &quot;foo&quot;, grid_height = unit(1, &quot;cm&quot;), grid_width = unit(5, &quot;mm&quot;)) The graphic parameters of labels are controlled by labels_gp. lgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = &quot;foo&quot;, labels_gp = gpar(col = &quot;red&quot;, fontsize = 14)) The graphic parameters of the title are controlled by title_gp. lgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = &quot;foo&quot;, title_gp = gpar(col = &quot;red&quot;, fontsize = 14)) Borders of grids are controlled by border. lgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = &quot;foo&quot;, border = &quot;red&quot;) One important thing for the discrete legend is you can arrange the grids into multiple rows or/and columns. If ncol is set to a number, the grids are arranged into ncol columns. lgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = &quot;foo&quot;, ncol = 3) Still the title position is calculated based on the multiplt-column legend. lgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = &quot;foo&quot;, ncol = 3, title_position = &quot;topcenter&quot;) You can choose to list the legend levels by rows by setting by_row = TRUE. lgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = &quot;foo&quot;, ncol = 3, by_row = TRUE) The gap between two columns are controlled by gap. lgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = &quot;foo&quot;, ncol = 3, gap = unit(1, &quot;cm&quot;)) Instead of ncol, you can also specify the layout by nrow. Note you cannot use ncol and nrow at a same time. lgd = Legend(labels = month.name[1:10], legend_gp = gpar(fill = 1:10), title = &quot;foo&quot;, nrow = 3) One extreme case is when all levels are put in one row and the title are rotated by 90 degree. The height of the legend will be the height of the rotated title. lgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = &quot;foooooo&quot;, nrow = 1, title_position = &quot;lefttop-rot&quot;) Following style a lot of people might like: lgd = Legend(labels = month.name[1:6], legend_gp = gpar(fill = 1:6), title = &quot;foooooo&quot;, nrow = 1, title_position = &quot;leftcenter&quot;) Legend() also supports to use simple graphics (e.g. points, lines) as legends. type argument can be specified as points that you can use number for pch or single-letter for pch. lgd = Legend(labels = month.name[1:6], title = &quot;foo&quot;, type = &quot;points&quot;, pch = 1:6, legend_gp = gpar(col = 1:6), background = &quot;#FF8080&quot;) lgd = Legend(labels = month.name[1:6], title = &quot;foo&quot;, type = &quot;points&quot;, pch = letters[1:6], legend_gp = gpar(col = 1:6), background = &quot;white&quot;) Or set type = &quot;lines&quot; to use lines as legend: lgd = Legend(labels = month.name[1:6], title = &quot;foo&quot;, type = &quot;lines&quot;, legend_gp = gpar(col = 1:6, lty = 1:6), grid_width = unit(1, &quot;cm&quot;)) 5.3 A list of legends A list of legends can also be constructed or packed as a Legends object where the individual legends are arranged in a certain layout. The legend list can be sent to packLegend() separatedly or as a list. The legend can be arranged either vertically or horizontally. lgd1 = Legend(at = 1:6, legend_gp = gpar(fill = 1:6), title = &quot;legend1&quot;) lgd2 = Legend(col_fun = col_fun, title = &quot;legend2&quot;, at = c(0, 0.25, 0.5, 0.75, 1)) lgd3 = Legend(labels = month.name[1:3], legend_gp = gpar(fill = 7:9), title = &quot;legend3&quot;) pd = packLegend(lgd1, lgd2, lgd3) # which is same as pd = packLegend(list = list(lgd1, lgd2, lgd3)) Simillar as single legend, you can draw the packed legends by draw() function. Also you can get the size of pd by width() and height(). width(pd) ## [1] 19.1162787543403mm height(pd) ## [1] 72.0757649739583mm Horizontally arranging the legends simply by setting direction = &quot;horizontal&quot;. pd = packLegend(lgd1, lgd2, lgd3, direction = &quot;horizontal&quot;) One feature of packLegend() is, e.g. if the packing is vertically and the sum of the packed legends exceeds the height specified by max_height, it will be rearragned as mutliple column layout. In following example, the maximum height is 10cm. When all the legends are put into multiple columns, column_gap controls the space between two columns. pd = packLegend(lgd1, lgd3, lgd2, lgd3, lgd2, lgd1, max_height = unit(10, &quot;cm&quot;), column_gap = unit(1, &quot;cm&quot;)) Similar for horizontal packing: lgd1 = Legend(at = 1:6, legend_gp = gpar(fill = 1:6), title = &quot;legend1&quot;, nr = 1) lgd2 = Legend(col_fun = col_fun, title = &quot;legend2&quot;, at = c(0, 0.25, 0.5, 0.75, 1), direction = &quot;horizontal&quot;) pd = packLegend(lgd1, lgd2, lgd3, lgd1, lgd2, lgd3, max_width = unit(10, &quot;cm&quot;), direction = &quot;horizontal&quot;, column_gap = unit(5, &quot;mm&quot;), row_gap = unit(1, &quot;cm&quot;)) 5.4 Heatmap and annotation legends m = matrix(rnorm(100), 10) Heatmap(m, name = &quot;foo&quot;, heatmap_legend_param = list( at = c(-2, 0, 2), labels = c(&quot;low&quot;, &quot;zero&quot;, &quot;high&quot;), title = &quot;Some values&quot;, legend_height = unit(4, &quot;cm&quot;), title_position = &quot;lefttop-rot&quot; )) ha = HeatmapAnnotation(foo = runif(10), bar = sample(c(&quot;f&quot;, &quot;m&quot;), 10, replace = TRUE), annotation_legend_param = list( foo = list( title = &quot;Fooooooo&quot;, at = c(0, 0.5, 1), labels = c(&quot;zero&quot;, &quot;median&quot;, &quot;one&quot;) ), bar = list( title = &quot;Baaaaaaar&quot;, at = c(&quot;f&quot;, &quot;m&quot;), labels = c(&quot;Female&quot;, &quot;Male&quot;) ) )) ha = HeatmapAnnotation(foo = runif(10), bar = sample(c(&quot;f&quot;, &quot;m&quot;), 10, replace = TRUE)) Heatmap(m, name = &quot;mat1&quot;, top_annotation = ha) + Heatmap(m, name = &quot;mat1&quot;, top_annotation = ha) ## Warning in .local(object, ...): Heatmap/annotation names are duplicated: ## mat1 ha = HeatmapAnnotation(foo = runif(10), bar = sample(c(&quot;f&quot;, &quot;m&quot;), 10, replace = TRUE), show_legend = c(TRUE, FALSE), annotation_name_side = &quot;left&quot;) Heatmap(m, name = &quot;mat1&quot;, top_annotation = ha) + Heatmap(m, name = &quot;mat2&quot;, show_heatmap_legend = FALSE) If heatmaps / annotations are added horizontally, heatmap legends and row annotations are put in one viewport and column annotations are put in another viewport ha1 = HeatmapAnnotation(foo1 = runif(10), bar1 = sample(c(&quot;f&quot;, &quot;m&quot;), 10, replace = TRUE)) ha2 = rowAnnotation(foo2 = runif(10), bar2 = sample(letters[1:3], 10, replace = TRUE)) ha3 = rowAnnotation(foo3 = runif(10), bar3 = sample(month.name[1:3], 10, replace = TRUE)) ht_list = Heatmap(m, name = &quot;mat1&quot;, top_annotation = ha1) + Heatmap(m, name = &quot;mat2&quot;, left_annotation = ha2) + ha3 draw(ht_list, heatmap_legend_side = &quot;bottom&quot;, annotation_legend_side = &quot;left&quot;) draw(ht_list, merge_legend = TRUE) 5.5 To add customized legend. 5.6 legends setting for the heatmaps "],
["heatmap-decoration.html", "Chapter 6 Heatmap decoration 6.1 decorate_* functions 6.2 Examples", " Chapter 6 Heatmap decoration Each component of the heatmap/heatmap list has a name (unique id). You can go to any viewport to add graphics in by specifying the heatmap/annotation name. First generate a figure that almost contains all types of heatmap components. mat = matrix(rnorm(80, 2), 8, 10) mat = rbind(mat, matrix(rnorm(40, -2), 4, 10)) rownames(mat) = paste0(&quot;R&quot;, 1:12) colnames(mat) = paste0(&quot;C&quot;, 1:10) ha_column1 = HeatmapAnnotation(points = anno_points(rnorm(10))) ht1 = Heatmap(mat, name = &quot;ht1&quot;, km = 2, column_title = &quot;Heatmap 1&quot;, top_annotation = ha_column1, row_names_side = &quot;left&quot;) ha_column2 = HeatmapAnnotation(type = c(rep(&quot;a&quot;, 5), rep(&quot;b&quot;, 5)), col = list(type = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;blue&quot;))) ht2 = Heatmap(mat, name = &quot;ht2&quot;, row_title = &quot;Heatmap 2&quot;, column_title = &quot;Heatmap 2&quot;, bottom_annotation = ha_column2, column_km = 2) ht_list = ht1 + ht2 + rowAnnotation(bar = anno_barplot(rowMeans(mat), width = unit(2, &quot;cm&quot;))) draw(ht_list, row_title = &quot;Heatmap list&quot;, column_title = &quot;Heatmap list&quot;) ComplexHeatmap:::list_component() ## [1] &quot;ROOT&quot; The components (viewports) that have names are: global: the viewport which contains the whole figure. global_column_title: the viewport which contains column title for the heatmap list. global_row_title: the viewport which contains row title for the heatmap list. main_heatmap_list: the viewport which contains a list of heatmaps and row annotations. heatmap_@{heatmap_name}: the viewport which contains a single heatmap annotation_@{annotation_name}: the viewport which contains an annotation on columns. annotation_@{annotation_name}_@{i}: for row annotations @{heatmap_name}_heatmap_body_@{i}: the heatmap body. @{heatmap_name}_column_title: column title for a single heatmap. @{heatmap_name}_row_title_@{i}: since a heatmap body may be splitted into several parts. @{i} is the index of the row slice. @{heatmap_name}_dend_row_@{i}: dendrogram for ith row slice. @{heatmap_name}_dend_column: dendrogram on columns @{heatmap_name}_row_names_@{i}: the viewport which contains row names. @{heatmap_name}_column_names: the viewport which contains column names. heatmap_legend: the viewport which contains all heatmap legends. legend_@{heatmap_name}: the viewport which contains a single heatmap legend. annotation_legend: the viewport which contains all annotation legends. legend_@{annotation_name}: the viewport which contains a single annotation legend. 6.1 decorate_* functions Basically, you can go to these components by seekViewport(), but to hide the details that is too low-level, ComplexHeatmap package provides decorate_* family functions which makes it easy to add graphics into different components. Following code add annotation names, mark one grid in the heatmap and seperate the first column clusters with two rectangles. ht_list = draw(ht_list, row_title = &quot;Heatmap list&quot;, column_title = &quot;Heatmap list&quot;, heatmap_legend_side = &quot;right&quot;, annotation_legend_side = &quot;left&quot;) decorate_heatmap_body(&quot;ht1&quot;, { grid.text(&quot;outlier&quot;, 1.5/10, 2.5/4, default.units = &quot;npc&quot;) grid.lines(c(0.5, 0.5), c(0, 1), gp = gpar(lty = 2, lwd = 2)) }, slice = 2) decorate_column_dend(&quot;ht1&quot;, { tree = column_dend(ht_list)$ht1[[1]] ind = cutree(as.hclust(tree), k = 2)[order.dendrogram(tree)] first_index = function(l) which(l)[1] last_index = function(l) { x = which(l); x[length(x)] } x1 = c(first_index(ind == 1), first_index(ind == 2)) - 1 x2 = c(last_index(ind == 1), last_index(ind == 2)) grid.rect(x = x1/length(ind), width = (x2 - x1)/length(ind), just = &quot;left&quot;, default.units = &quot;npc&quot;, gp = gpar(fill = c(&quot;#FF000040&quot;, &quot;#00FF0040&quot;), col = NA)) }) decorate_row_names(&quot;ht1&quot;, { grid.rect(gp = gpar(fill = &quot;#FF000040&quot;)) }, slice = 2) decorate_row_title(&quot;ht1&quot;, { grid.rect(gp = gpar(fill = &quot;#00FF0040&quot;)) }, slice = 1) decorate_annotation(&quot;points&quot;, { grid.lines(c(0, 1), unit(c(0, 0), &quot;native&quot;), gp = gpar(col = &quot;red&quot;)) }) For annotations which are created by anno_points(), anno_barplot() and anno_boxplot(), “native” unit can be used in the decoration code. 6.2 Examples 6.2.1 Barplot for single column heatmap le = c(sample(letters[1:3], 400, prob = c(7, 2, 1), replace = TRUE), sample(letters[1:3], 600, prob = c(2, 3, 5), replace = TRUE)) col = c(&quot;a&quot; = &quot;red&quot;, &quot;b&quot; = &quot;green&quot;, &quot;c&quot; = &quot;blue&quot;) split = c(rep(&quot;group1&quot;, 400), rep(&quot;group2&quot;, 600)) ht = Heatmap(le, name = &quot;letters&quot;, col = col, width = unit(3, &quot;cm&quot;), top_annotation = HeatmapAnnotation(barplot = anno_empty(height = unit(4, &quot;cm&quot;)))) ht = draw(ht, split = split) ## Since all heatmaps/annotations have absolute units, the total width of the plot is 56mm ro = row_order(ht) lt = lapply(ro, function(index) { t = table(le[index]) t/sum(t) }) decorate_annotation(&quot;barplot&quot;, { pushViewport(viewport(xscale = c(0.5, 2.5), yscale = c(0, 1))) grid.rect(x = 1, y = cumsum(lt[[1]]), width = 0.8, height = lt[[1]], just = &quot;top&quot;, gp = gpar(fill = col), default.units = &quot;native&quot;) grid.rect(x = 2, y = cumsum(lt[[2]]), width = 0.8, height = lt[[2]], just = &quot;top&quot;, gp = gpar(fill = col), default.units = &quot;native&quot;) grid.yaxis() grid.text(&quot;Relative proportion&quot;, x = unit(-1.5, &quot;cm&quot;),rot = 90, just = &quot;bottom&quot;) popViewport() }) 6.2.2 add decoration for a customized heatmap customized_heatmap = function(m, ...) { post_fun = function(ht) { m = ht@matrix co = column_order(ht) cm = colMeans(m)[co] nc = ncol(m) ind = which(cm &lt; 0) if(length(ind)) { decorate_heatmap_body(ht@name, { grid.rect((ind - 1)/nc, 0.5, 1/nc, 1, gp = gpar(col = &quot;black&quot;, lwd = 2, fill = NA), just = &quot;left&quot;) }) } } x = colMeans(m) Heatmap(m, ..., top_annotation = HeatmapAnnotation(mean = anno_barplot(x, gp = gpar(fill = ifelse(x &gt; 0, &quot;red&quot;, &quot;green&quot;)), width = unit(4, &quot;cm&quot;))), post_fun = post_fun) } m1 = matrix(rnorm(100), nr = 10) m2 = matrix(rnorm(100), nr = 10) customized_heatmap(m1) %v% customized_heatmap(m2) "],
["oncoprint.html", "Chapter 7 OncoPrint 7.1 General settings 7.2 Apply to cBioPortal dataset 7.3 Session info 7.4 density heatmap 7.5 stacked plot", " Chapter 7 OncoPrint OncoPrint is a way to visualize multiple genomic alteration events by heatmap. Here the ComplexHeatmap package provides a oncoPrint() function. Besides the default style which is provided by cBioPortal, there are additional barplots at both sides of the heatmap which show numbers of different alterations for each sample and for each gene. Also with the functionality of ComplexHeatmap, you can control oncoPrint with more flexibilities. 7.1 General settings There are two different forms of input data. The first is represented as a matrix in which element would include multiple alterations in a form of a complex string. In follow example, ‘g1’ in ‘s1’ has two types of alterations which are ‘snv’ and ‘indel’. mat = read.table(textConnection( &quot;,s1,s2,s3 g1,snv;indel,snv,indel g2,,snv;indel,snv g3,snv,,indel;snv&quot;), row.names = 1, header = TRUE, sep = &quot;,&quot;, stringsAsFactors = FALSE) mat = as.matrix(mat) mat ## s1 s2 s3 ## g1 &quot;snv;indel&quot; &quot;snv&quot; &quot;indel&quot; ## g2 &quot;&quot; &quot;snv;indel&quot; &quot;snv&quot; ## g3 &quot;snv&quot; &quot;&quot; &quot;indel;snv&quot; In this case, we need to define a function to extract different alteration types and pass the function to get_type argument. The function should return a vector of alteration types. For one gene in one sample, since different alteration types may be drawn into one same grid in the heatmap, we need to define how to add the graphics by self-defined functions. Here if the graphics have no transparency, orders of how to add graphics matters. In following example, snv are first drawn and then the indel. You can see rectangles for indels are actually smaller than that for snvs so that you can visualiza both snvs and indels if they are in a same grid. Names in the list of functions should correspond to the alteration types (here, snv and indel). For the self-defined graphic function, there should be four arguments which are positions of the grids on the heatmap (x and y), and widths and heights of the grids (w and h). Colors for different alterations are defined in col. It should be a named vector for which names correspond to alteration types. It is used to generate the barplots and the legends. library(ComplexHeatmap) col = c(snv = &quot;red&quot;, indel = &quot;blue&quot;) oncoPrint(mat, get_type = function(x) strsplit(x, &quot;;&quot;)[[1]], alter_fun = list( snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = col[&quot;snv&quot;], col = NA)), indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, gp = gpar(fill = col[&quot;indel&quot;], col = NA)) ), col = col) ## All mutation types: snv, indel In above example, form of the string (e.g. snv;indel) correlates to how you define get_type. If the string has the form of snv|indel|amp, get_type should be defined as function(x) strsplit(x, &quot;|&quot;)[[1]]. If you are pulzzed by how to generated the matrix, there is a second way. The second type of input data is a list of matrix for which each matrix contains binary value representing whether the alteration is absent or present. The list should have names which correspond to the alteration types. mat_list = list(snv = matrix(c(1, 0, 1, 1, 1, 0, 0, 1, 1), nrow = 3), indel = matrix(c(1, 0, 0, 0, 1, 0, 1, 0, 0), nrow = 3)) rownames(mat_list$snv) = rownames(mat_list$indel) = c(&quot;g1&quot;, &quot;g2&quot;, &quot;g3&quot;) colnames(mat_list$snv) = colnames(mat_list$indel) = c(&quot;s1&quot;, &quot;s2&quot;, &quot;s3&quot;) mat_list ## $snv ## s1 s2 s3 ## g1 1 1 0 ## g2 0 1 1 ## g3 1 0 1 ## ## $indel ## s1 s2 s3 ## g1 1 0 1 ## g2 0 1 0 ## g3 0 0 0 oncoPrint() expects all matrix in mat_list having same row names and column names. Users can use unify_mat_list() to adjust the matrix list. mat_list2 = mat_list mat_list2$indel = mat_list2$indel[1:2, 1:2] mat_list2 ## $snv ## s1 s2 s3 ## g1 1 1 0 ## g2 0 1 1 ## g3 1 0 1 ## ## $indel ## s1 s2 ## g1 1 0 ## g2 0 1 mat_list2 = unify_mat_list(mat_list2) mat_list2 ## $snv ## s1 s2 s3 ## g1 1 1 0 ## g2 0 1 1 ## g3 1 0 1 ## ## $indel ## s1 s2 s3 ## g1 1 0 0 ## g2 0 1 0 ## g3 0 0 0 Pass mat_list to oncoPrint(): oncoPrint(mat_list, alter_fun = list( snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = col[&quot;snv&quot;], col = NA)), indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, gp = gpar(fill = col[&quot;indel&quot;], col = NA)) ), col = col) ## All mutation types: snv, indel In above examples, alter_fun is a list of functons which add graphics layer by layer. Graphics can also be added in a grid-by-grid style by specifying alter_fun as a single function. The difference from the function list is now alter_fun should accept a fifth argument which is a logical vector. This logical vector shows whether different alterations exist for current gene in current sample. Let’s assume in a grid there is only snv event, v for this grid is: ## snv indel ## TRUE FALSE oncoPrint(mat_list, alter_fun = function(x, y, w, h, v) { if(v[&quot;snv&quot;]) grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = col[&quot;snv&quot;], col = NA)) if(v[&quot;indel&quot;]) grid.rect(x, y, w*0.9, h*0.4, gp = gpar(fill = col[&quot;indel&quot;], col = NA)) }, col = col) ## All mutation types: snv, indel If alter_fun is set as a single function, customization can be more flexible. In following example, rectangles always fill the whole grid evenly. oncoPrint(mat_list, alter_fun = function(x, y, w, h, v) { n = sum(v) h = h*0.9 # use `names(which(v))` to correctly map between `v` and `col` if(n) grid.rect(x, y - h*0.5 + 1:n/n*h, w*0.9, 1/n*h, gp = gpar(fill = col[names(which(v))], col = NA), just = &quot;top&quot;) }, col = col) ## All mutation types: snv, indel With a single function for alter_fun, you can define different graphics for different alterations. In following plot, you need to adjust the height of the whole plot to make sure the height for each cell is more than double of the width. snv_fun = function(x, y, w, h) { grid.rect(x, y, w, h, gp = gpar(fill = col[&quot;snv&quot;], col = NA)) } indel_fun = function(x, y, r) { grid.circle(x, y, r, gp = gpar(fill = col[&quot;indel&quot;], col = NA)) } oncoPrint(mat, get_type = function(x) strsplit(x, &quot;;&quot;)[[1]], alter_fun = function(x, y, w, h, v) { n = sum(v) w = convertWidth(w, &quot;cm&quot;)*0.9 h = convertHeight(h, &quot;cm&quot;)*0.9 l = min(unit.c(w, h)) grid.rect(x, y, w, h, gp = gpar(fill = &quot;grey&quot;, col = NA)) if(n == 0) return(NULL) if(n == 1) { if(names(which(v)) == &quot;snv&quot;) snv_fun(x, y, l, l) if(names(which(v)) == &quot;indel&quot;) indel_fun(x, y, l*0.5) } else if(n == 2) { snv_fun(x, y-0.25*h, l, l) indel_fun(x, y+0.25*h, l*0.5) } }, col = col) ## All mutation types: snv, indel If alter_fun is specified as a list, the order of the elements controls the order of adding graphics. There is a special element named background which defines how to draw background and it should be always put as the first element in the alter_fun list. In following example, backgrond color is changed to light green with borders. oncoPrint(mat_list, alter_fun = list( background = function(x, y, w, h) grid.rect(x, y, w, h, gp = gpar(fill = &quot;#00FF0020&quot;)), snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = col[&quot;snv&quot;], col = NA)), indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, gp = gpar(fill = col[&quot;indel&quot;], col = NA)) ), col = col) ## All mutation types: snv, indel Or just remove the background: oncoPrint(mat_list, alter_fun = list( background = NULL, snv = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = col[&quot;snv&quot;], col = NA)), indel = function(x, y, w, h) grid.rect(x, y, w*0.9, h*0.4, gp = gpar(fill = col[&quot;indel&quot;], col = NA)) ), col = col) ## All mutation types: snv, indel You can customize the oncoprot by self-defining alter_fun. But be careful you must convert w and h to absolute units. oncoPrint(mat, get_type = function(x) strsplit(x, &quot;;&quot;)[[1]], alter_fun = list( snv = function(x, y, w, h) { w = convertWidth(w, &quot;cm&quot;) h = convertHeight(h, &quot;cm&quot;) l = min(unit.c(w, h)) grid.rect(x, y, l*0.9, l*0.9, gp = gpar(fill = col[&quot;snv&quot;], col = NA)) }, indel = function(x, y, w, h) { w = convertWidth(w, &quot;cm&quot;) h = convertHeight(h, &quot;cm&quot;) r = min(unit.c(w, h))*0.5 grid.circle(x, y, r*0.9, gp = gpar(fill = col[&quot;indel&quot;], col = NA)) } ), col = col) ## All mutation types: snv, indel 7.2 Apply to cBioPortal dataset Now we make an oncoPrint with a real-world data. The data is retrieved from cBioPortal. Steps for getting the data are as follows: go to http://www.cbioportal.org search Cancer Study: “Lung Adenocarcinoma Carcinoma” and select: “Lung Adenocarcinoma Carcinoma (TCGA, Provisinal)” In “Enter Gene Set” field, select: “General: Ras-Raf-MEK-Erk/JNK signaling (26 genes)” submit the form In the results page, go to “Download” tab, download text in “Type of Genetic alterations across all cases” The order of samples can also be downloaded from the results page, go to “OncoPrint” tab, move the mouse above the plot, click “download” icon and click “Sample order” First we read the data and do some pre-processing. mat = read.table(paste0(system.file(&quot;extdata&quot;, package = &quot;ComplexHeatmap&quot;), &quot;/tcga_lung_adenocarcinoma_provisional_ras_raf_mek_jnk_signalling.txt&quot;), header = TRUE,stringsAsFactors=FALSE, sep = &quot;\\t&quot;) mat[is.na(mat)] = &quot;&quot; rownames(mat) = mat[, 1] mat = mat[, -1] mat= mat[, -ncol(mat)] mat = t(as.matrix(mat)) mat[1:3, 1:3] ## TCGA-05-4384-01 TCGA-05-4390-01 TCGA-05-4425-01 ## KRAS &quot; &quot; &quot;MUT;&quot; &quot; &quot; ## HRAS &quot; &quot; &quot; &quot; &quot; &quot; ## BRAF &quot; &quot; &quot; &quot; &quot; &quot; There are three different alterations in mat: HOMDEL, AMP and MUT. We first define how to add graphics which correspond to different alterations. alter_fun = list( background = function(x, y, w, h) { grid.rect(x, y, w-unit(0.5, &quot;mm&quot;), h-unit(0.5, &quot;mm&quot;), gp = gpar(fill = &quot;#CCCCCC&quot;, col = NA)) }, HOMDEL = function(x, y, w, h) { grid.rect(x, y, w-unit(0.5, &quot;mm&quot;), h-unit(0.5, &quot;mm&quot;), gp = gpar(fill = &quot;blue&quot;, col = NA)) }, AMP = function(x, y, w, h) { grid.rect(x, y, w-unit(0.5, &quot;mm&quot;), h-unit(0.5, &quot;mm&quot;), gp = gpar(fill = &quot;red&quot;, col = NA)) }, MUT = function(x, y, w, h) { grid.rect(x, y, w-unit(0.5, &quot;mm&quot;), h*0.33, gp = gpar(fill = &quot;#008000&quot;, col = NA)) } ) Also colors for different alterations which will be used for barplots. col = c(&quot;MUT&quot; = &quot;#008000&quot;, &quot;AMP&quot; = &quot;red&quot;, &quot;HOMDEL&quot; = &quot;blue&quot;) Make the oncoPrint and adjust heatmap components such as the title and the legend. oncoPrint(mat, get_type = function(x) strsplit(x, &quot;;&quot;)[[1]], alter_fun = alter_fun, col = col, column_title = &quot;OncoPrint for TCGA Lung Adenocarcinoma, genes in Ras Raf MEK JNK signalling&quot;, heatmap_legend_param = list(title = &quot;Alternations&quot;, at = c(&quot;AMP&quot;, &quot;HOMDEL&quot;, &quot;MUT&quot;), labels = c(&quot;Amplification&quot;, &quot;Deep deletion&quot;, &quot;Mutation&quot;))) ## All mutation types: MUT, AMP, HOMDEL As you see, the genes and samples are sorted automatically. Rows are sorted based on the frequency of the alterations in all samples and columns are sorted to visualize the mutual exclusivity across genes based on the “memo sort” method which is kindly provided by B. Arman Aksoy. If you want to turn off the default sorting, set row_order or column_order to NULL. By default, if one sample has no alteration, it will still remain in the heatmap, but you can set remove_empty_columns to TRUE to remove it: oncoPrint(mat, get_type = function(x) strsplit(x, &quot;;&quot;)[[1]], alter_fun = alter_fun, col = col, remove_empty_columns = TRUE, column_title = &quot;OncoPrint for TCGA Lung Adenocarcinoma, genes in Ras Raf MEK JNK signalling&quot;, heatmap_legend_param = list(title = &quot;Alternations&quot;, at = c(&quot;AMP&quot;, &quot;HOMDEL&quot;, &quot;MUT&quot;), labels = c(&quot;Amplification&quot;, &quot;Deep deletion&quot;, &quot;Mutation&quot;))) ## All mutation types: MUT, AMP, HOMDEL As the normal Heatmap() function, row_order or column_order can be assigned with a vector of orders (either numeric or character). Following the order of samples are gathered from cBio as well. You can see the difference for the sample order between ‘memo sort’ and the method used by cBio. Also notice how we move the legend to the bottom of the oncoPrint. sample_order = scan(paste0(system.file(&quot;extdata&quot;, package = &quot;ComplexHeatmap&quot;), &quot;/sample_order.txt&quot;), what = &quot;character&quot;) ht = oncoPrint(mat, get_type = function(x) strsplit(x, &quot;;&quot;)[[1]], alter_fun = alter_fun, col = col, row_order = NULL, column_order = sample_order, remove_empty_columns = TRUE, column_title = &quot;OncoPrint for TCGA Lung Adenocarcinoma, genes in Ras Raf MEK JNK signalling&quot;, heatmap_legend_param = list(title = &quot;Alternations&quot;, at = c(&quot;AMP&quot;, &quot;HOMDEL&quot;, &quot;MUT&quot;), labels = c(&quot;Amplification&quot;, &quot;Deep deletion&quot;, &quot;Mutation&quot;), nrow = 1, title_position = &quot;leftcenter&quot;)) ## All mutation types: MUT, AMP, HOMDEL draw(ht, heatmap_legend_side = &quot;bottom&quot;) oncoPrint() actually returns a HeatmapList object, so you can add more Heatmaps or row annotations to it to visualize more complicated information. Following example splits the heatmap into two halves and add a new heatmap to the right. ht_list = oncoPrint(mat, get_type = function(x) strsplit(x, &quot;;&quot;)[[1]], alter_fun = alter_fun, col = col, remove_empty_columns = TRUE, column_title = &quot;OncoPrint for TCGA Lung Adenocarcinoma, genes in Ras Raf MEK JNK signalling&quot;, heatmap_legend_param = list(title = &quot;Alternations&quot;, at = c(&quot;AMP&quot;, &quot;HOMDEL&quot;, &quot;MUT&quot;), labels = c(&quot;Amplification&quot;, &quot;Deep deletion&quot;, &quot;Mutation&quot;)), split = sample(letters[1:2], nrow(mat), replace = TRUE)) + Heatmap(matrix(rnorm(nrow(mat)*10), ncol = 10), name = &quot;expr&quot;, show_column_dend = FALSE, width = unit(4, &quot;cm&quot;)) ## All mutation types: MUT, AMP, HOMDEL draw(ht_list, row_sub_title_side = &quot;left&quot;) If you make the plot in an interactive device (e.g. X11 or Rstudio IDE), the generation of the plot may be very slow. In this case, we suggest users to directly save the plot to a separate file (e.g. using png() or pdf()) and then visualize the plot afterwards. 7.3 Session info sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS High Sierra 10.13.2 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8 ## ## attached base packages: ## [1] grid methods stats graphics grDevices utils datasets ## [8] base ## ## other attached packages: ## [1] dendsort_0.3.3 dendextend_1.8.0 circlize_0.4.5 ## [4] ComplexHeatmap_1.99.0 ## ## loaded via a namespace (and not attached): ## [1] shape_1.4.4 modeltools_0.2-22 GetoptLong_0.1.7 ## [4] tidyselect_0.2.4 xfun_0.3 kernlab_0.9-27 ## [7] purrr_0.2.5 lattice_0.20-35 colorspace_1.3-2 ## [10] viridisLite_0.3.0 htmltools_0.3.6 stats4_3.4.4 ## [13] yaml_2.2.0 rlang_0.2.2 pillar_1.3.0 ## [16] glue_1.3.0 prabclus_2.2-6 RColorBrewer_1.1-2 ## [19] fpc_2.1-11.1 bindrcpp_0.2.2 plyr_1.8.4 ## [22] bindr_0.1.1 robustbase_0.93-2 stringr_1.3.1 ## [25] munsell_0.5.0 gtable_0.2.0 mvtnorm_1.0-8 ## [28] GlobalOptions_0.1.1 evaluate_0.11 knitr_1.20 ## [31] flexmix_2.3-14 class_7.3-14 DEoptimR_1.0-8 ## [34] trimcluster_0.1-2.1 Rcpp_0.12.18 scales_1.0.0 ## [37] backports_1.1.2 diptest_0.75-7 gridExtra_2.3 ## [40] rjson_0.2.20 ggplot2_3.0.0 digest_0.6.17 ## [43] stringi_1.2.4 bookdown_0.7 dplyr_0.7.6 ## [46] rprojroot_1.3-2 tools_3.4.4 magrittr_1.5 ## [49] lazyeval_0.2.1 tibble_1.4.2 cluster_2.0.7-1 ## [52] crayon_1.3.4 whisker_0.3-2 pkgconfig_2.0.2 ## [55] MASS_7.3-50 viridis_0.5.1 assertthat_0.2.0 ## [58] rmarkdown_1.10 R6_2.2.2 mclust_5.4.1 ## [61] nnet_7.3-12 compiler_3.4.4 7.4 density heatmap 7.5 stacked plot "],
["more-examples-of-making-complex-heatmaps.html", "Chapter 8 More Examples of Making Complex Heatmaps 8.1 Combine pvclust and heatmap 8.2 Make a same plot as heatmap() 8.3 The measles vaccine heatmap 8.4 Session info", " Chapter 8 More Examples of Making Complex Heatmaps In the supplementaries of the ComplexHeatmap paper, there are four comprehensive examples which are applied on real-world high-throughput datasets. The examples can be found here. Also my blog has some examples and tips for making better complex heatmaps. 8.0.1 Add more information for gene expression matrix Heatmaps are very popular to visualize gene expression matrix. Rows in the matrix correspond to genes and more information on these genes can be attached after the expression heatmap. In following example, the big heatmap visualize relative expression for genes, then the next is the absolute expression. Also gene length and gene type (i.e. protein coding or lincRNA) are visualized. library(ComplexHeatmap) library(circlize) expr = readRDS(paste0(system.file(package = &quot;ComplexHeatmap&quot;), &quot;/extdata/gene_expression.rds&quot;)) mat = as.matrix(expr[, grep(&quot;cell&quot;, colnames(expr))]) base_mean = rowMeans(mat) mat_scaled = t(apply(mat, 1, scale)) type = gsub(&quot;s\\\\d+_&quot;, &quot;&quot;, colnames(mat)) ha = HeatmapAnnotation(df = data.frame(type = type)) Heatmap(mat_scaled, name = &quot;expression&quot;, km = 5, col = colorRamp2(c(-2, 0, 2), c(&quot;green&quot;, &quot;white&quot;, &quot;red&quot;)), top_annotation = ha, show_row_names = FALSE, show_column_names = FALSE) + Heatmap(base_mean, name = &quot;base_mean&quot;, show_row_names = FALSE, width = unit(5, &quot;mm&quot;)) + Heatmap(expr$length, name = &quot;length&quot;, col = colorRamp2(c(0, 1000000), c(&quot;white&quot;, &quot;orange&quot;)), heatmap_legend_param = list(at = c(0, 200000, 400000, 60000, 800000, 1000000), labels = c(&quot;0kb&quot;, &quot;200kb&quot;, &quot;400kb&quot;, &quot;600kb&quot;, &quot;800kb&quot;, &quot;1mb&quot;)), width = unit(5, &quot;mm&quot;)) + Heatmap(expr$type, name = &quot;type&quot;, width = unit(5, &quot;mm&quot;)) 8.0.2 Visualize genomic regions and other correspondance Following example visualizes correlation between methylation and expression, as well as other annotation information (data are randomly generated). In the heatmap, each row corresponds to a differentially methylated regions (DMRs). From left to right, heatmaps are: methylation for each DMR (by rows) in samples. direction of the methylation (one column heatmap), i.e. is methylation hyper in tumor or hypo? expression for the genes that are associated with corresponding DMRs (e.g. closest gene). significance for the correlation between methylation and expression (-log10(p-value)). type of genes, i.e. is the gene a protein coding gene or a lincRNA? annotation to gene models, i.e. is the DMR located in the intragenic region of the corresponding gene or the DMR is intergenic? distance from the DMR to the TSS of the corresponding gene. overlapping between DMRs and enhancers (Color shows how much the DMR is covered by the enhancers). ## Warning: The input is a data frame, convert it to the matrix. 8.1 Combine pvclust and heatmap pvclust package provides a robust way to test the stability of the clustering by random sampling from original data. Here you can organize the heatmap by the clustering returned from pvclust(). library(ComplexHeatmap) library(MASS) library(pvclust) data(Boston) boston.pv &lt;- pvclust(Boston, nboot=100) ## Bootstrap (r = 0.5)... Done. ## Bootstrap (r = 0.6)... Done. ## Bootstrap (r = 0.7)... Done. ## Bootstrap (r = 0.8)... Done. ## Bootstrap (r = 0.9)... Done. ## Bootstrap (r = 1.0)... Done. ## Bootstrap (r = 1.1)... Done. ## Bootstrap (r = 1.2)... Done. ## Bootstrap (r = 1.3)... Done. ## Bootstrap (r = 1.4)... Done. plot(boston.pv) Since by default pvclust clusters columns by ‘correlation’ method, we scale columns for Boston data set to see the relative trend. Boston_scaled = apply(Boston, 2, scale) Heatmap(Boston_scaled, cluster_columns = boston.pv$hclust, heatmap_legend_param = list(title = &quot;Boston&quot;)) 8.2 Make a same plot as heatmap() set.seed(123) mat = matrix(rnorm(100), 10) heatmap(mat, col = topo.colors(50)) Compare to the native heatmap(), Heatmap() can give more accurate interpolation for colors for continous values. Heatmap(mat, col = topo.colors(50), color_space = &quot;sRGB&quot;, row_dend_width = unit(2, &quot;cm&quot;), column_dend_height = unit(2, &quot;cm&quot;), row_dend_reorder = TRUE, column_dend_reorder = TRUE) 8.3 The measles vaccine heatmap Following code reproduces the heatmap introduced here and here. mat = readRDS(paste0(system.file(&quot;extdata&quot;, package = &quot;ComplexHeatmap&quot;), &quot;/measles.rds&quot;)) ha1 = HeatmapAnnotation(dist1 = anno_barplot(colSums(mat), bar_width = 1, gp = gpar(col = NA, fill = &quot;#FFE200&quot;), border = FALSE, axis = TRUE)) ha2 = rowAnnotation(dist2 = anno_barplot(rowSums(mat), bar_width = 1, gp = gpar(col = NA, fill = &quot;#FFE200&quot;), border = FALSE, which = &quot;row&quot;, axis = TRUE), width = unit(1, &quot;cm&quot;)) ha_column = HeatmapAnnotation(cn = function(index) { year = as.numeric(colnames(mat)) which_decade = which(year %% 10 == 0) grid.text(year[which_decade], which_decade/length(year), 1, just = c(&quot;center&quot;, &quot;top&quot;)) }) Heatmap(mat, name = &quot;cases&quot;, col = colorRamp2(c(0, 800, 1000, 127000), c(&quot;white&quot;, &quot;cornflowerblue&quot;, &quot;yellow&quot;, &quot;red&quot;)), cluster_columns = FALSE, show_row_dend = FALSE, rect_gp = gpar(col= &quot;white&quot;), show_column_names = FALSE, row_names_side = &quot;left&quot;, row_names_gp = gpar(fontsize = 10), column_title = &#39;Measles cases in US states 1930-2001\\nVaccine introduced 1961&#39;, top_annotation = ha1, bottom_annotation = ha_column) + ha2 decorate_heatmap_body(&quot;cases&quot;, { i = which(colnames(mat) == &quot;1961&quot;) x = i/ncol(mat) grid.lines(c(x, x), c(0, 1), gp = gpar(lwd = 2)) grid.text(&quot;Vaccine introduced&quot;, x, unit(1, &quot;npc&quot;) + unit(5, &quot;mm&quot;)) }) 8.4 Session info sessionInfo() ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS High Sierra 10.13.2 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.4/Resources/lib/libRlapack.dylib ## ## locale: ## [1] en_GB.UTF-8/en_GB.UTF-8/en_GB.UTF-8/C/en_GB.UTF-8/en_GB.UTF-8 ## ## attached base packages: ## [1] grid methods stats graphics grDevices utils datasets ## [8] base ## ## other attached packages: ## [1] pvclust_2.0-0 MASS_7.3-50 RColorBrewer_1.1-2 ## [4] dendsort_0.3.3 dendextend_1.8.0 circlize_0.4.5 ## [7] ComplexHeatmap_1.99.0 ## ## loaded via a namespace (and not attached): ## [1] shape_1.4.4 modeltools_0.2-22 GetoptLong_0.1.7 ## [4] tidyselect_0.2.4 xfun_0.3 kernlab_0.9-27 ## [7] purrr_0.2.5 lattice_0.20-35 colorspace_1.3-2 ## [10] viridisLite_0.3.0 htmltools_0.3.6 stats4_3.4.4 ## [13] yaml_2.2.0 rlang_0.2.2 pillar_1.3.0 ## [16] glue_1.3.0 prabclus_2.2-6 fpc_2.1-11.1 ## [19] bindrcpp_0.2.2 plyr_1.8.4 bindr_0.1.1 ## [22] robustbase_0.93-2 stringr_1.3.1 munsell_0.5.0 ## [25] gtable_0.2.0 mvtnorm_1.0-8 GlobalOptions_0.1.1 ## [28] evaluate_0.11 knitr_1.20 flexmix_2.3-14 ## [31] class_7.3-14 DEoptimR_1.0-8 trimcluster_0.1-2.1 ## [34] Rcpp_0.12.18 scales_1.0.0 backports_1.1.2 ## [37] diptest_0.75-7 gridExtra_2.3 rjson_0.2.20 ## [40] ggplot2_3.0.0 digest_0.6.17 stringi_1.2.4 ## [43] bookdown_0.7 dplyr_0.7.6 rprojroot_1.3-2 ## [46] tools_3.4.4 magrittr_1.5 lazyeval_0.2.1 ## [49] tibble_1.4.2 cluster_2.0.7-1 crayon_1.3.4 ## [52] whisker_0.3-2 pkgconfig_2.0.2 viridis_0.5.1 ## [55] assertthat_0.2.0 rmarkdown_1.10 R6_2.2.2 ## [58] mclust_5.4.1 nnet_7.3-12 compiler_3.4.4 "]
]
